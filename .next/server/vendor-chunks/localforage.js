"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/localforage";
exports.ids = ["vendor-chunks/localforage"];
exports.modules = {

/***/ "(ssr)/./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n/*!\n    localForage -- Offline Storage, Improved\n    Version 1.10.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/ (function(f) {\n    if (true) {\n        module.exports = f();\n    } else { var g; }\n})(function() {\n    var define1, module1, exports1;\n    return (function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = undefined;\n                    if (!u && a) return require(o, !0);\n                    if (i) return i(o, !0);\n                    var f = new Error(\"Cannot find module '\" + o + \"'\");\n                    throw f.code = \"MODULE_NOT_FOUND\", f;\n                }\n                var l = n[o] = {\n                    exports: {}\n                };\n                t[o][0].call(l.exports, function(e) {\n                    var n = t[o][1][e];\n                    return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }\n            return n[o].exports;\n        }\n        var i = undefined;\n        for(var o = 0; o < r.length; o++)s(r[o]);\n        return s;\n    })({\n        1: [\n            function(_dereq_, module1, exports1) {\n                (function(global1) {\n                    \"use strict\";\n                    var Mutation = global1.MutationObserver || global1.WebKitMutationObserver;\n                    var scheduleDrain;\n                    {\n                        if (Mutation) {\n                            var called = 0;\n                            var observer = new Mutation(nextTick);\n                            var element = global1.document.createTextNode(\"\");\n                            observer.observe(element, {\n                                characterData: true\n                            });\n                            scheduleDrain = function() {\n                                element.data = called = ++called % 2;\n                            };\n                        } else if (!global1.setImmediate && typeof global1.MessageChannel !== \"undefined\") {\n                            var channel = new global1.MessageChannel();\n                            channel.port1.onmessage = nextTick;\n                            scheduleDrain = function() {\n                                channel.port2.postMessage(0);\n                            };\n                        } else if (\"document\" in global1 && \"onreadystatechange\" in global1.document.createElement(\"script\")) {\n                            scheduleDrain = function() {\n                                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                                var scriptEl = global1.document.createElement(\"script\");\n                                scriptEl.onreadystatechange = function() {\n                                    nextTick();\n                                    scriptEl.onreadystatechange = null;\n                                    scriptEl.parentNode.removeChild(scriptEl);\n                                    scriptEl = null;\n                                };\n                                global1.document.documentElement.appendChild(scriptEl);\n                            };\n                        } else {\n                            scheduleDrain = function() {\n                                setTimeout(nextTick, 0);\n                            };\n                        }\n                    }\n                    var draining;\n                    var queue = [];\n                    //named nextTick for less confusing stack traces\n                    function nextTick() {\n                        draining = true;\n                        var i, oldQueue;\n                        var len = queue.length;\n                        while(len){\n                            oldQueue = queue;\n                            queue = [];\n                            i = -1;\n                            while(++i < len){\n                                oldQueue[i]();\n                            }\n                            len = queue.length;\n                        }\n                        draining = false;\n                    }\n                    module1.exports = immediate;\n                    function immediate(task) {\n                        if (queue.push(task) === 1 && !draining) {\n                            scheduleDrain();\n                        }\n                    }\n                }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {});\n            },\n            {}\n        ],\n        2: [\n            function(_dereq_, module1, exports1) {\n                \"use strict\";\n                var immediate = _dereq_(1);\n                /* istanbul ignore next */ function INTERNAL() {}\n                var handlers = {};\n                var REJECTED = [\n                    \"REJECTED\"\n                ];\n                var FULFILLED = [\n                    \"FULFILLED\"\n                ];\n                var PENDING = [\n                    \"PENDING\"\n                ];\n                module1.exports = Promise1;\n                function Promise1(resolver) {\n                    if (typeof resolver !== \"function\") {\n                        throw new TypeError(\"resolver must be a function\");\n                    }\n                    this.state = PENDING;\n                    this.queue = [];\n                    this.outcome = void 0;\n                    if (resolver !== INTERNAL) {\n                        safelyResolveThenable(this, resolver);\n                    }\n                }\n                Promise1.prototype[\"catch\"] = function(onRejected) {\n                    return this.then(null, onRejected);\n                };\n                Promise1.prototype.then = function(onFulfilled, onRejected) {\n                    if (typeof onFulfilled !== \"function\" && this.state === FULFILLED || typeof onRejected !== \"function\" && this.state === REJECTED) {\n                        return this;\n                    }\n                    var promise = new this.constructor(INTERNAL);\n                    if (this.state !== PENDING) {\n                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n                        unwrap(promise, resolver, this.outcome);\n                    } else {\n                        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n                    }\n                    return promise;\n                };\n                function QueueItem(promise, onFulfilled, onRejected) {\n                    this.promise = promise;\n                    if (typeof onFulfilled === \"function\") {\n                        this.onFulfilled = onFulfilled;\n                        this.callFulfilled = this.otherCallFulfilled;\n                    }\n                    if (typeof onRejected === \"function\") {\n                        this.onRejected = onRejected;\n                        this.callRejected = this.otherCallRejected;\n                    }\n                }\n                QueueItem.prototype.callFulfilled = function(value) {\n                    handlers.resolve(this.promise, value);\n                };\n                QueueItem.prototype.otherCallFulfilled = function(value) {\n                    unwrap(this.promise, this.onFulfilled, value);\n                };\n                QueueItem.prototype.callRejected = function(value) {\n                    handlers.reject(this.promise, value);\n                };\n                QueueItem.prototype.otherCallRejected = function(value) {\n                    unwrap(this.promise, this.onRejected, value);\n                };\n                function unwrap(promise, func, value) {\n                    immediate(function() {\n                        var returnValue;\n                        try {\n                            returnValue = func(value);\n                        } catch (e) {\n                            return handlers.reject(promise, e);\n                        }\n                        if (returnValue === promise) {\n                            handlers.reject(promise, new TypeError(\"Cannot resolve promise with itself\"));\n                        } else {\n                            handlers.resolve(promise, returnValue);\n                        }\n                    });\n                }\n                handlers.resolve = function(self1, value) {\n                    var result = tryCatch(getThen, value);\n                    if (result.status === \"error\") {\n                        return handlers.reject(self1, result.value);\n                    }\n                    var thenable = result.value;\n                    if (thenable) {\n                        safelyResolveThenable(self1, thenable);\n                    } else {\n                        self1.state = FULFILLED;\n                        self1.outcome = value;\n                        var i = -1;\n                        var len = self1.queue.length;\n                        while(++i < len){\n                            self1.queue[i].callFulfilled(value);\n                        }\n                    }\n                    return self1;\n                };\n                handlers.reject = function(self1, error) {\n                    self1.state = REJECTED;\n                    self1.outcome = error;\n                    var i = -1;\n                    var len = self1.queue.length;\n                    while(++i < len){\n                        self1.queue[i].callRejected(error);\n                    }\n                    return self1;\n                };\n                function getThen(obj) {\n                    // Make sure we only access the accessor once as required by the spec\n                    var then = obj && obj.then;\n                    if (obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof then === \"function\") {\n                        return function appyThen() {\n                            then.apply(obj, arguments);\n                        };\n                    }\n                }\n                function safelyResolveThenable(self1, thenable) {\n                    // Either fulfill, reject or reject with error\n                    var called = false;\n                    function onError(value) {\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        handlers.reject(self1, value);\n                    }\n                    function onSuccess(value) {\n                        if (called) {\n                            return;\n                        }\n                        called = true;\n                        handlers.resolve(self1, value);\n                    }\n                    function tryToUnwrap() {\n                        thenable(onSuccess, onError);\n                    }\n                    var result = tryCatch(tryToUnwrap);\n                    if (result.status === \"error\") {\n                        onError(result.value);\n                    }\n                }\n                function tryCatch(func, value) {\n                    var out = {};\n                    try {\n                        out.value = func(value);\n                        out.status = \"success\";\n                    } catch (e) {\n                        out.status = \"error\";\n                        out.value = e;\n                    }\n                    return out;\n                }\n                Promise1.resolve = resolve;\n                function resolve(value) {\n                    if (value instanceof this) {\n                        return value;\n                    }\n                    return handlers.resolve(new this(INTERNAL), value);\n                }\n                Promise1.reject = reject;\n                function reject(reason) {\n                    var promise = new this(INTERNAL);\n                    return handlers.reject(promise, reason);\n                }\n                Promise1.all = all;\n                function all(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") {\n                        return this.reject(new TypeError(\"must be an array\"));\n                    }\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) {\n                        return this.resolve([]);\n                    }\n                    var values = new Array(len);\n                    var resolved = 0;\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len){\n                        allResolver(iterable[i], i);\n                    }\n                    return promise;\n                    function allResolver(value, i) {\n                        self1.resolve(value).then(resolveFromAll, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                        function resolveFromAll(outValue) {\n                            values[i] = outValue;\n                            if (++resolved === len && !called) {\n                                called = true;\n                                handlers.resolve(promise, values);\n                            }\n                        }\n                    }\n                }\n                Promise1.race = race;\n                function race(iterable) {\n                    var self1 = this;\n                    if (Object.prototype.toString.call(iterable) !== \"[object Array]\") {\n                        return this.reject(new TypeError(\"must be an array\"));\n                    }\n                    var len = iterable.length;\n                    var called = false;\n                    if (!len) {\n                        return this.resolve([]);\n                    }\n                    var i = -1;\n                    var promise = new this(INTERNAL);\n                    while(++i < len){\n                        resolver(iterable[i]);\n                    }\n                    return promise;\n                    function resolver(value) {\n                        self1.resolve(value).then(function(response) {\n                            if (!called) {\n                                called = true;\n                                handlers.resolve(promise, response);\n                            }\n                        }, function(error) {\n                            if (!called) {\n                                called = true;\n                                handlers.reject(promise, error);\n                            }\n                        });\n                    }\n                }\n            },\n            {\n                \"1\": 1\n            }\n        ],\n        3: [\n            function(_dereq_, module1, exports1) {\n                (function(global1) {\n                    \"use strict\";\n                    if (typeof global1.Promise !== \"function\") {\n                        global1.Promise = _dereq_(2);\n                    }\n                }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {});\n            },\n            {\n                \"2\": 2\n            }\n        ],\n        4: [\n            function(_dereq_, module1, exports1) {\n                \"use strict\";\n                var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                };\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                function getIDB() {\n                    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */ try {\n                        if (typeof indexedDB !== \"undefined\") {\n                            return indexedDB;\n                        }\n                        if (typeof webkitIndexedDB !== \"undefined\") {\n                            return webkitIndexedDB;\n                        }\n                        if (typeof mozIndexedDB !== \"undefined\") {\n                            return mozIndexedDB;\n                        }\n                        if (typeof OIndexedDB !== \"undefined\") {\n                            return OIndexedDB;\n                        }\n                        if (typeof msIndexedDB !== \"undefined\") {\n                            return msIndexedDB;\n                        }\n                    } catch (e) {\n                        return;\n                    }\n                }\n                var idb = getIDB();\n                function isIndexedDBValid() {\n                    try {\n                        // Initialize IndexedDB; fall back to vendor-prefixed versions\n                        // if needed.\n                        if (!idb || !idb.open) {\n                            return false;\n                        }\n                        // We mimic PouchDB here;\n                        //\n                        // We test for openDatabase because IE Mobile identifies itself\n                        // as Safari. Oh the lulz...\n                        var isSafari = typeof openDatabase !== \"undefined\" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n                        var hasFetch = typeof fetch === \"function\" && fetch.toString().indexOf(\"[native code\") !== -1;\n                        // Safari <10.1 does not meet our requirements for IDB support\n                        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n                        // Safari 10.1 shipped with fetch, we can use that to detect it.\n                        // Note: this creates issues with `window.fetch` polyfills and\n                        // overrides; see:\n                        // https://github.com/localForage/localForage/issues/856\n                        return (!isSafari || hasFetch) && typeof indexedDB !== \"undefined\" && // some outdated implementations of IDB that appear on Samsung\n                        // and HTC Android devices <4.4 are missing IDBKeyRange\n                        // See: https://github.com/mozilla/localForage/issues/128\n                        // See: https://github.com/mozilla/localForage/issues/272\n                        typeof IDBKeyRange !== \"undefined\";\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                // Abstracts constructing a Blob object, so it also works in older\n                // browsers that don't support the native Blob constructor. (i.e.\n                // old QtWebKit versions, at least).\n                function createBlob(parts, properties) {\n                    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */ parts = parts || [];\n                    properties = properties || {};\n                    try {\n                        return new Blob(parts, properties);\n                    } catch (e) {\n                        if (e.name !== \"TypeError\") {\n                            throw e;\n                        }\n                        var Builder = typeof BlobBuilder !== \"undefined\" ? BlobBuilder : typeof MSBlobBuilder !== \"undefined\" ? MSBlobBuilder : typeof MozBlobBuilder !== \"undefined\" ? MozBlobBuilder : WebKitBlobBuilder;\n                        var builder = new Builder();\n                        for(var i = 0; i < parts.length; i += 1){\n                            builder.append(parts[i]);\n                        }\n                        return builder.getBlob(properties.type);\n                    }\n                }\n                // This is CommonJS because lie is an external dependency, so Rollup\n                // can just ignore it.\n                if (typeof Promise === \"undefined\") {\n                    // In the \"nopromises\" build this will just throw if you don't have\n                    // a global promise object, but it would throw anyway later.\n                    _dereq_(3);\n                }\n                var Promise$1 = Promise;\n                function executeCallback(promise, callback) {\n                    if (callback) {\n                        promise.then(function(result) {\n                            callback(null, result);\n                        }, function(error) {\n                            callback(error);\n                        });\n                    }\n                }\n                function executeTwoCallbacks(promise, callback, errorCallback) {\n                    if (typeof callback === \"function\") {\n                        promise.then(callback);\n                    }\n                    if (typeof errorCallback === \"function\") {\n                        promise[\"catch\"](errorCallback);\n                    }\n                }\n                function normalizeKey(key) {\n                    // Cast the key to a string, as that's all we can set as a key.\n                    if (typeof key !== \"string\") {\n                        console.warn(key + \" used as a key, but it is not a string.\");\n                        key = String(key);\n                    }\n                    return key;\n                }\n                function getCallback() {\n                    if (arguments.length && typeof arguments[arguments.length - 1] === \"function\") {\n                        return arguments[arguments.length - 1];\n                    }\n                }\n                // Some code originally from async_storage.js in\n                // [Gaia](https://github.com/mozilla-b2g/gaia).\n                var DETECT_BLOB_SUPPORT_STORE = \"local-forage-detect-blob-support\";\n                var supportsBlobs = void 0;\n                var dbContexts = {};\n                var toString = Object.prototype.toString;\n                // Transaction Modes\n                var READ_ONLY = \"readonly\";\n                var READ_WRITE = \"readwrite\";\n                // Transform a binary string to an array buffer, because otherwise\n                // weird stuff happens when you try to work with the binary string directly.\n                // It is known.\n                // From http://stackoverflow.com/questions/14967647/ (continues on next line)\n                // encode-decode-image-with-base64-breaks-image (2013-04-21)\n                function _binStringToArrayBuffer(bin) {\n                    var length = bin.length;\n                    var buf = new ArrayBuffer(length);\n                    var arr = new Uint8Array(buf);\n                    for(var i = 0; i < length; i++){\n                        arr[i] = bin.charCodeAt(i);\n                    }\n                    return buf;\n                }\n                //\n                // Blobs are not supported in all versions of IndexedDB, notably\n                // Chrome <37 and Android <5. In those versions, storing a blob will throw.\n                //\n                // Various other blob bugs exist in Chrome v37-42 (inclusive).\n                // Detecting them is expensive and confusing to users, and Chrome 37-42\n                // is at very low usage worldwide, so we do a hacky userAgent check instead.\n                //\n                // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n                // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n                // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n                //\n                // Code borrowed from PouchDB. See:\n                // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n                //\n                function _checkBlobSupportWithoutCaching(idb) {\n                    return new Promise$1(function(resolve) {\n                        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n                        var blob = createBlob([\n                            \"\"\n                        ]);\n                        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, \"key\");\n                        txn.onabort = function(e) {\n                            // If the transaction aborts now its due to not being able to\n                            // write to the database, likely due to the disk being full\n                            e.preventDefault();\n                            e.stopPropagation();\n                            resolve(false);\n                        };\n                        txn.oncomplete = function() {\n                            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n                            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n                            // MS Edge pretends to be Chrome 42:\n                            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n                            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n                        };\n                    })[\"catch\"](function() {\n                        return false; // error, so assume unsupported\n                    });\n                }\n                function _checkBlobSupport(idb) {\n                    if (typeof supportsBlobs === \"boolean\") {\n                        return Promise$1.resolve(supportsBlobs);\n                    }\n                    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n                        supportsBlobs = value;\n                        return supportsBlobs;\n                    });\n                }\n                function _deferReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Create a deferred object representing the current database operation.\n                    var deferredOperation = {};\n                    deferredOperation.promise = new Promise$1(function(resolve, reject) {\n                        deferredOperation.resolve = resolve;\n                        deferredOperation.reject = reject;\n                    });\n                    // Enqueue the deferred operation.\n                    dbContext.deferredOperations.push(deferredOperation);\n                    // Chain its promise to the database readiness.\n                    if (!dbContext.dbReady) {\n                        dbContext.dbReady = deferredOperation.promise;\n                    } else {\n                        dbContext.dbReady = dbContext.dbReady.then(function() {\n                            return deferredOperation.promise;\n                        });\n                    }\n                }\n                function _advanceReadiness(dbInfo) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Resolve its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.resolve();\n                        return deferredOperation.promise;\n                    }\n                }\n                function _rejectReadiness(dbInfo, err) {\n                    var dbContext = dbContexts[dbInfo.name];\n                    // Dequeue a deferred operation.\n                    var deferredOperation = dbContext.deferredOperations.pop();\n                    // Reject its promise (which is part of the database readiness\n                    // chain of promises).\n                    if (deferredOperation) {\n                        deferredOperation.reject(err);\n                        return deferredOperation.promise;\n                    }\n                }\n                function _getConnection(dbInfo, upgradeNeeded) {\n                    return new Promise$1(function(resolve, reject) {\n                        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n                        if (dbInfo.db) {\n                            if (upgradeNeeded) {\n                                _deferReadiness(dbInfo);\n                                dbInfo.db.close();\n                            } else {\n                                return resolve(dbInfo.db);\n                            }\n                        }\n                        var dbArgs = [\n                            dbInfo.name\n                        ];\n                        if (upgradeNeeded) {\n                            dbArgs.push(dbInfo.version);\n                        }\n                        var openreq = idb.open.apply(idb, dbArgs);\n                        if (upgradeNeeded) {\n                            openreq.onupgradeneeded = function(e) {\n                                var db = openreq.result;\n                                try {\n                                    db.createObjectStore(dbInfo.storeName);\n                                    if (e.oldVersion <= 1) {\n                                        // Added when support for blob shims was added\n                                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                                    }\n                                } catch (ex) {\n                                    if (ex.name === \"ConstraintError\") {\n                                        console.warn('The database \"' + dbInfo.name + '\"' + \" has been upgraded from version \" + e.oldVersion + \" to version \" + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                                    } else {\n                                        throw ex;\n                                    }\n                                }\n                            };\n                        }\n                        openreq.onerror = function(e) {\n                            e.preventDefault();\n                            reject(openreq.error);\n                        };\n                        openreq.onsuccess = function() {\n                            var db = openreq.result;\n                            db.onversionchange = function(e) {\n                                // Triggered when the database is modified (e.g. adding an objectStore) or\n                                // deleted (even when initiated by other sessions in different tabs).\n                                // Closing the connection here prevents those operations from being blocked.\n                                // If the database is accessed again later by this instance, the connection\n                                // will be reopened or the database recreated as needed.\n                                e.target.close();\n                            };\n                            resolve(db);\n                            _advanceReadiness(dbInfo);\n                        };\n                    });\n                }\n                function _getOriginalConnection(dbInfo) {\n                    return _getConnection(dbInfo, false);\n                }\n                function _getUpgradedConnection(dbInfo) {\n                    return _getConnection(dbInfo, true);\n                }\n                function _isUpgradeNeeded(dbInfo, defaultVersion) {\n                    if (!dbInfo.db) {\n                        return true;\n                    }\n                    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n                    var isDowngrade = dbInfo.version < dbInfo.db.version;\n                    var isUpgrade = dbInfo.version > dbInfo.db.version;\n                    if (isDowngrade) {\n                        // If the version is not the default one\n                        // then warn for impossible downgrade.\n                        if (dbInfo.version !== defaultVersion) {\n                            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + \" to version \" + dbInfo.version + \".\");\n                        }\n                        // Align the versions to prevent errors.\n                        dbInfo.version = dbInfo.db.version;\n                    }\n                    if (isUpgrade || isNewStore) {\n                        // If the store is new then increment the version (if needed).\n                        // This will trigger an \"upgradeneeded\" event which is required\n                        // for creating a store.\n                        if (isNewStore) {\n                            var incVersion = dbInfo.db.version + 1;\n                            if (incVersion > dbInfo.version) {\n                                dbInfo.version = incVersion;\n                            }\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n                // encode a blob for indexeddb engines that don't support blobs\n                function _encodeBlob(blob) {\n                    return new Promise$1(function(resolve, reject) {\n                        var reader = new FileReader();\n                        reader.onerror = reject;\n                        reader.onloadend = function(e) {\n                            var base64 = btoa(e.target.result || \"\");\n                            resolve({\n                                __local_forage_encoded_blob: true,\n                                data: base64,\n                                type: blob.type\n                            });\n                        };\n                        reader.readAsBinaryString(blob);\n                    });\n                }\n                // decode an encoded blob\n                function _decodeBlob(encodedBlob) {\n                    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n                    return createBlob([\n                        arrayBuff\n                    ], {\n                        type: encodedBlob.type\n                    });\n                }\n                // is this one of our fancy encoded blobs?\n                function _isEncodedBlob(value) {\n                    return value && value.__local_forage_encoded_blob;\n                }\n                // Specialize the default `ready()` function by making it dependent\n                // on the current database operations. Thus, the driver will be actually\n                // ready when it's been initialized (default) *and* there are no pending\n                // operations on the database (initiated by some other instances).\n                function _fullyReady(callback) {\n                    var self1 = this;\n                    var promise = self1._initReady().then(function() {\n                        var dbContext = dbContexts[self1._dbInfo.name];\n                        if (dbContext && dbContext.dbReady) {\n                            return dbContext.dbReady;\n                        }\n                    });\n                    executeTwoCallbacks(promise, callback, callback);\n                    return promise;\n                }\n                // Try to establish a new db connection to replace the\n                // current one which is broken (i.e. experiencing\n                // InvalidStateError while creating a transaction).\n                function _tryReconnect(dbInfo) {\n                    _deferReadiness(dbInfo);\n                    var dbContext = dbContexts[dbInfo.name];\n                    var forages = dbContext.forages;\n                    for(var i = 0; i < forages.length; i++){\n                        var forage = forages[i];\n                        if (forage._dbInfo.db) {\n                            forage._dbInfo.db.close();\n                            forage._dbInfo.db = null;\n                        }\n                    }\n                    dbInfo.db = null;\n                    return _getOriginalConnection(dbInfo).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo)) {\n                            // Reopen the database for upgrading.\n                            return _getUpgradedConnection(dbInfo);\n                        }\n                        return db;\n                    }).then(function(db) {\n                        // store the latest db reference\n                        // in case the db was upgraded\n                        dbInfo.db = dbContext.db = db;\n                        for(var i = 0; i < forages.length; i++){\n                            forages[i]._dbInfo.db = db;\n                        }\n                    })[\"catch\"](function(err) {\n                        _rejectReadiness(dbInfo, err);\n                        throw err;\n                    });\n                }\n                // FF doesn't like Promises (micro-tasks) and IDDB store operations,\n                // so we have to do it with callbacks\n                function createTransaction(dbInfo, mode, callback, retries) {\n                    if (retries === undefined) {\n                        retries = 1;\n                    }\n                    try {\n                        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                        callback(null, tx);\n                    } catch (err) {\n                        if (retries > 0 && (!dbInfo.db || err.name === \"InvalidStateError\" || err.name === \"NotFoundError\")) {\n                            return Promise$1.resolve().then(function() {\n                                if (!dbInfo.db || err.name === \"NotFoundError\" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                                    // increase the db version, to create the new ObjectStore\n                                    if (dbInfo.db) {\n                                        dbInfo.version = dbInfo.db.version + 1;\n                                    }\n                                    // Reopen the database for upgrading.\n                                    return _getUpgradedConnection(dbInfo);\n                                }\n                            }).then(function() {\n                                return _tryReconnect(dbInfo).then(function() {\n                                    createTransaction(dbInfo, mode, callback, retries - 1);\n                                });\n                            })[\"catch\"](callback);\n                        }\n                        callback(err);\n                    }\n                }\n                function createDbContext() {\n                    return {\n                        // Running localForages sharing a database.\n                        forages: [],\n                        // Shared database.\n                        db: null,\n                        // Database readiness (promise).\n                        dbReady: null,\n                        // Deferred operations on the database.\n                        deferredOperations: []\n                    };\n                }\n                // Open the IndexedDB database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = options[i];\n                        }\n                    }\n                    // Get the current context of the database;\n                    var dbContext = dbContexts[dbInfo.name];\n                    // ...or create a new context.\n                    if (!dbContext) {\n                        dbContext = createDbContext();\n                        // Register the new context in the global container.\n                        dbContexts[dbInfo.name] = dbContext;\n                    }\n                    // Register itself as a running localForage in the current context.\n                    dbContext.forages.push(self1);\n                    // Replace the default `ready()` function with the specialized one.\n                    if (!self1._initReady) {\n                        self1._initReady = self1.ready;\n                        self1.ready = _fullyReady;\n                    }\n                    // Create an array of initialization states of the related localForages.\n                    var initPromises = [];\n                    function ignoreErrors() {\n                        // Don't handle errors here,\n                        // just makes sure related localForages aren't pending.\n                        return Promise$1.resolve();\n                    }\n                    for(var j = 0; j < dbContext.forages.length; j++){\n                        var forage = dbContext.forages[j];\n                        if (forage !== self1) {\n                            // Don't wait for itself...\n                            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n                        }\n                    }\n                    // Take a snapshot of the related localForages.\n                    var forages = dbContext.forages.slice(0);\n                    // Initialize the connection process only when\n                    // all the related localForages aren't pending.\n                    return Promise$1.all(initPromises).then(function() {\n                        dbInfo.db = dbContext.db;\n                        // Get the connection or open a new one without upgrade.\n                        return _getOriginalConnection(dbInfo);\n                    }).then(function(db) {\n                        dbInfo.db = db;\n                        if (_isUpgradeNeeded(dbInfo, self1._defaultConfig.version)) {\n                            // Reopen the database for upgrading.\n                            return _getUpgradedConnection(dbInfo);\n                        }\n                        return db;\n                    }).then(function(db) {\n                        dbInfo.db = dbContext.db = db;\n                        self1._dbInfo = dbInfo;\n                        // Share the final connection amongst related localForages.\n                        for(var k = 0; k < forages.length; k++){\n                            var forage = forages[k];\n                            if (forage !== self1) {\n                                // Self is already up-to-date.\n                                forage._dbInfo.db = dbInfo.db;\n                                forage._dbInfo.version = dbInfo.version;\n                            }\n                        }\n                    });\n                }\n                function getItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.get(key);\n                                    req.onsuccess = function() {\n                                        var value = req.result;\n                                        if (value === undefined) {\n                                            value = null;\n                                        }\n                                        if (_isEncodedBlob(value)) {\n                                            value = _decodeBlob(value);\n                                        }\n                                        resolve(value);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items stored in database.\n                function iterate(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openCursor();\n                                    var iterationNumber = 1;\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (cursor) {\n                                            var value = cursor.value;\n                                            if (_isEncodedBlob(value)) {\n                                                value = _decodeBlob(value);\n                                            }\n                                            var result = iterator(value, cursor.key, iterationNumber++);\n                                            // when the iterator callback returns any\n                                            // (non-`undefined`) value, then we stop\n                                            // the iteration immediately\n                                            if (result !== void 0) {\n                                                resolve(result);\n                                            } else {\n                                                cursor[\"continue\"]();\n                                            }\n                                        } else {\n                                            resolve();\n                                        }\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        var dbInfo;\n                        self1.ready().then(function() {\n                            dbInfo = self1._dbInfo;\n                            if (toString.call(value) === \"[object Blob]\") {\n                                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {\n                                    if (blobSupport) {\n                                        return value;\n                                    }\n                                    return _encodeBlob(value);\n                                });\n                            }\n                            return value;\n                        }).then(function(value) {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // The reason we don't _save_ null is because IE 10 does\n                                    // not support saving the `null` type in IndexedDB. How\n                                    // ironic, given the bug below!\n                                    // See: https://github.com/mozilla/localForage/issues/161\n                                    if (value === null) {\n                                        value = undefined;\n                                    }\n                                    var req = store.put(value, key);\n                                    transaction.oncomplete = function() {\n                                        // Cast to undefined so the value passed to\n                                        // callback/promise is the same as what one would get out\n                                        // of `getItem()` later. This leads to some weirdness\n                                        // (setItem('foo', undefined) will return `null`), but\n                                        // it's not my fault localStorage is our baseline and that\n                                        // it's weird.\n                                        if (value === undefined) {\n                                            value = null;\n                                        }\n                                        resolve(value);\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function removeItem(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    // We use a Grunt task to make this safe for IE and some\n                                    // versions of Android (including those used by Cordova).\n                                    // Normally IE won't like `.delete()` and will insist on\n                                    // using `['delete']()`, but we have a build step that\n                                    // fixes this for us now.\n                                    var req = store[\"delete\"](key);\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                    // The request will be also be aborted if we've exceeded our storage\n                                    // space.\n                                    transaction.onabort = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function clear(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_WRITE, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.clear();\n                                    transaction.oncomplete = function() {\n                                        resolve();\n                                    };\n                                    transaction.onabort = transaction.onerror = function() {\n                                        var err = req.error ? req.error : req.transaction.error;\n                                        reject(err);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function length(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.count();\n                                    req.onsuccess = function() {\n                                        resolve(req.result);\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function key(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        if (n < 0) {\n                            resolve(null);\n                            return;\n                        }\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var advanced = false;\n                                    var req = store.openKeyCursor();\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            // this means there weren't enough keys\n                                            resolve(null);\n                                            return;\n                                        }\n                                        if (n === 0) {\n                                            // We have the first key, return it if that's what they\n                                            // wanted.\n                                            resolve(cursor.key);\n                                        } else {\n                                            if (!advanced) {\n                                                // Otherwise, ask the cursor to skip ahead n\n                                                // records.\n                                                advanced = true;\n                                                cursor.advance(n);\n                                            } else {\n                                                // When we get here, we've got the nth key.\n                                                resolve(cursor.key);\n                                            }\n                                        }\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            createTransaction(self1._dbInfo, READ_ONLY, function(err, transaction) {\n                                if (err) {\n                                    return reject(err);\n                                }\n                                try {\n                                    var store = transaction.objectStore(self1._dbInfo.storeName);\n                                    var req = store.openKeyCursor();\n                                    var keys = [];\n                                    req.onsuccess = function() {\n                                        var cursor = req.result;\n                                        if (!cursor) {\n                                            resolve(keys);\n                                            return;\n                                        }\n                                        keys.push(cursor.key);\n                                        cursor[\"continue\"]();\n                                    };\n                                    req.onerror = function() {\n                                        reject(req.error);\n                                    };\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        var isCurrentDb = options.name === currentConfig.name && self1._dbInfo.db;\n                        var dbPromise = isCurrentDb ? Promise$1.resolve(self1._dbInfo.db) : _getOriginalConnection(options).then(function(db) {\n                            var dbContext = dbContexts[options.name];\n                            var forages = dbContext.forages;\n                            dbContext.db = db;\n                            for(var i = 0; i < forages.length; i++){\n                                forages[i]._dbInfo.db = db;\n                            }\n                            return db;\n                        });\n                        if (!options.storeName) {\n                            promise = dbPromise.then(function(db) {\n                                _deferReadiness(options);\n                                var dbContext = dbContexts[options.name];\n                                var forages = dbContext.forages;\n                                db.close();\n                                for(var i = 0; i < forages.length; i++){\n                                    var forage = forages[i];\n                                    forage._dbInfo.db = null;\n                                }\n                                var dropDBPromise = new Promise$1(function(resolve, reject) {\n                                    var req = idb.deleteDatabase(options.name);\n                                    req.onerror = function() {\n                                        var db = req.result;\n                                        if (db) {\n                                            db.close();\n                                        }\n                                        reject(req.error);\n                                    };\n                                    req.onblocked = function() {\n                                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                                        console.warn('dropInstance blocked for database \"' + options.name + '\" until all open connections are closed');\n                                    };\n                                    req.onsuccess = function() {\n                                        var db = req.result;\n                                        if (db) {\n                                            db.close();\n                                        }\n                                        resolve(db);\n                                    };\n                                });\n                                return dropDBPromise.then(function(db) {\n                                    dbContext.db = db;\n                                    for(var i = 0; i < forages.length; i++){\n                                        var _forage = forages[i];\n                                        _advanceReadiness(_forage._dbInfo);\n                                    }\n                                })[\"catch\"](function(err) {\n                                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                    throw err;\n                                });\n                            });\n                        } else {\n                            promise = dbPromise.then(function(db) {\n                                if (!db.objectStoreNames.contains(options.storeName)) {\n                                    return;\n                                }\n                                var newVersion = db.version + 1;\n                                _deferReadiness(options);\n                                var dbContext = dbContexts[options.name];\n                                var forages = dbContext.forages;\n                                db.close();\n                                for(var i = 0; i < forages.length; i++){\n                                    var forage = forages[i];\n                                    forage._dbInfo.db = null;\n                                    forage._dbInfo.version = newVersion;\n                                }\n                                var dropObjectPromise = new Promise$1(function(resolve, reject) {\n                                    var req = idb.open(options.name, newVersion);\n                                    req.onerror = function(err) {\n                                        var db = req.result;\n                                        db.close();\n                                        reject(err);\n                                    };\n                                    req.onupgradeneeded = function() {\n                                        var db = req.result;\n                                        db.deleteObjectStore(options.storeName);\n                                    };\n                                    req.onsuccess = function() {\n                                        var db = req.result;\n                                        db.close();\n                                        resolve(db);\n                                    };\n                                });\n                                return dropObjectPromise.then(function(db) {\n                                    dbContext.db = db;\n                                    for(var j = 0; j < forages.length; j++){\n                                        var _forage2 = forages[j];\n                                        _forage2._dbInfo.db = db;\n                                        _advanceReadiness(_forage2._dbInfo);\n                                    }\n                                })[\"catch\"](function(err) {\n                                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function() {});\n                                    throw err;\n                                });\n                            });\n                        }\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var asyncStorage = {\n                    _driver: \"asyncStorage\",\n                    _initStorage: _initStorage,\n                    _support: isIndexedDBValid(),\n                    iterate: iterate,\n                    getItem: getItem,\n                    setItem: setItem,\n                    removeItem: removeItem,\n                    clear: clear,\n                    length: length,\n                    key: key,\n                    keys: keys,\n                    dropInstance: dropInstance\n                };\n                function isWebSQLValid() {\n                    return typeof openDatabase === \"function\";\n                }\n                // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n                // it to Base64, so this is how we store it to prevent very strange errors with less\n                // verbose ways of binary <-> string data storage.\n                var BASE_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n                var BLOB_TYPE_PREFIX = \"~~local_forage_type~\";\n                var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n                var SERIALIZED_MARKER = \"__lfsc__:\";\n                var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n                // OMG the serializations!\n                var TYPE_ARRAYBUFFER = \"arbf\";\n                var TYPE_BLOB = \"blob\";\n                var TYPE_INT8ARRAY = \"si08\";\n                var TYPE_UINT8ARRAY = \"ui08\";\n                var TYPE_UINT8CLAMPEDARRAY = \"uic8\";\n                var TYPE_INT16ARRAY = \"si16\";\n                var TYPE_INT32ARRAY = \"si32\";\n                var TYPE_UINT16ARRAY = \"ur16\";\n                var TYPE_UINT32ARRAY = \"ui32\";\n                var TYPE_FLOAT32ARRAY = \"fl32\";\n                var TYPE_FLOAT64ARRAY = \"fl64\";\n                var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n                var toString$1 = Object.prototype.toString;\n                function stringToBuffer(serializedString) {\n                    // Fill the string into a ArrayBuffer.\n                    var bufferLength = serializedString.length * 0.75;\n                    var len = serializedString.length;\n                    var i;\n                    var p = 0;\n                    var encoded1, encoded2, encoded3, encoded4;\n                    if (serializedString[serializedString.length - 1] === \"=\") {\n                        bufferLength--;\n                        if (serializedString[serializedString.length - 2] === \"=\") {\n                            bufferLength--;\n                        }\n                    }\n                    var buffer = new ArrayBuffer(bufferLength);\n                    var bytes = new Uint8Array(buffer);\n                    for(i = 0; i < len; i += 4){\n                        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n                        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n                        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n                        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n                        /*jslint bitwise: true */ bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n                        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n                        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n                    }\n                    return buffer;\n                }\n                // Converts a buffer to a string to store, serialized, in the backend\n                // storage library.\n                function bufferToString(buffer) {\n                    // base64-arraybuffer\n                    var bytes = new Uint8Array(buffer);\n                    var base64String = \"\";\n                    var i;\n                    for(i = 0; i < bytes.length; i += 3){\n                        /*jslint bitwise: true */ base64String += BASE_CHARS[bytes[i] >> 2];\n                        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n                        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n                        base64String += BASE_CHARS[bytes[i + 2] & 63];\n                    }\n                    if (bytes.length % 3 === 2) {\n                        base64String = base64String.substring(0, base64String.length - 1) + \"=\";\n                    } else if (bytes.length % 3 === 1) {\n                        base64String = base64String.substring(0, base64String.length - 2) + \"==\";\n                    }\n                    return base64String;\n                }\n                // Serialize a value, afterwards executing a callback (which usually\n                // instructs the `setItem()` callback/promise to be executed). This is how\n                // we store binary data with localStorage.\n                function serialize(value, callback) {\n                    var valueType = \"\";\n                    if (value) {\n                        valueType = toString$1.call(value);\n                    }\n                    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n                    // checks fail when running the tests using casper.js...\n                    //\n                    // TODO: See why those tests fail and use a better solution.\n                    if (value && (valueType === \"[object ArrayBuffer]\" || value.buffer && toString$1.call(value.buffer) === \"[object ArrayBuffer]\")) {\n                        // Convert binary arrays to a string and prefix the string with\n                        // a special marker.\n                        var buffer;\n                        var marker = SERIALIZED_MARKER;\n                        if (value instanceof ArrayBuffer) {\n                            buffer = value;\n                            marker += TYPE_ARRAYBUFFER;\n                        } else {\n                            buffer = value.buffer;\n                            if (valueType === \"[object Int8Array]\") {\n                                marker += TYPE_INT8ARRAY;\n                            } else if (valueType === \"[object Uint8Array]\") {\n                                marker += TYPE_UINT8ARRAY;\n                            } else if (valueType === \"[object Uint8ClampedArray]\") {\n                                marker += TYPE_UINT8CLAMPEDARRAY;\n                            } else if (valueType === \"[object Int16Array]\") {\n                                marker += TYPE_INT16ARRAY;\n                            } else if (valueType === \"[object Uint16Array]\") {\n                                marker += TYPE_UINT16ARRAY;\n                            } else if (valueType === \"[object Int32Array]\") {\n                                marker += TYPE_INT32ARRAY;\n                            } else if (valueType === \"[object Uint32Array]\") {\n                                marker += TYPE_UINT32ARRAY;\n                            } else if (valueType === \"[object Float32Array]\") {\n                                marker += TYPE_FLOAT32ARRAY;\n                            } else if (valueType === \"[object Float64Array]\") {\n                                marker += TYPE_FLOAT64ARRAY;\n                            } else {\n                                callback(new Error(\"Failed to get type for BinaryArray\"));\n                            }\n                        }\n                        callback(marker + bufferToString(buffer));\n                    } else if (valueType === \"[object Blob]\") {\n                        // Conver the blob to a binaryArray and then to a string.\n                        var fileReader = new FileReader();\n                        fileReader.onload = function() {\n                            // Backwards-compatible prefix for the blob type.\n                            var str = BLOB_TYPE_PREFIX + value.type + \"~\" + bufferToString(this.result);\n                            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n                        };\n                        fileReader.readAsArrayBuffer(value);\n                    } else {\n                        try {\n                            callback(JSON.stringify(value));\n                        } catch (e) {\n                            console.error(\"Couldn't convert value into a JSON string: \", value);\n                            callback(null, e);\n                        }\n                    }\n                }\n                // Deserialize data we've inserted into a value column/field. We place\n                // special markers into our strings to mark them as encoded; this isn't\n                // as nice as a meta field, but it's the only sane thing we can do whilst\n                // keeping localStorage support intact.\n                //\n                // Oftentimes this will just deserialize JSON content, but if we have a\n                // special marker (SERIALIZED_MARKER, defined above), we will extract\n                // some kind of arraybuffer/binary data/typed array out of the string.\n                function deserialize(value) {\n                    // If we haven't marked this string as being specially serialized (i.e.\n                    // something other than serialized JSON), we can just return it and be\n                    // done with it.\n                    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n                        return JSON.parse(value);\n                    }\n                    // The following code deals with deserializing some kind of Blob or\n                    // TypedArray. First we separate out the type of data we're dealing\n                    // with from the data itself.\n                    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n                    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n                    var blobType;\n                    // Backwards-compatible blob type serialization strategy.\n                    // DBs created with older versions of localForage will simply not have the blob type.\n                    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n                        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n                        blobType = matcher[1];\n                        serializedString = serializedString.substring(matcher[0].length);\n                    }\n                    var buffer = stringToBuffer(serializedString);\n                    // Return the right type based on the code/type set during\n                    // serialization.\n                    switch(type){\n                        case TYPE_ARRAYBUFFER:\n                            return buffer;\n                        case TYPE_BLOB:\n                            return createBlob([\n                                buffer\n                            ], {\n                                type: blobType\n                            });\n                        case TYPE_INT8ARRAY:\n                            return new Int8Array(buffer);\n                        case TYPE_UINT8ARRAY:\n                            return new Uint8Array(buffer);\n                        case TYPE_UINT8CLAMPEDARRAY:\n                            return new Uint8ClampedArray(buffer);\n                        case TYPE_INT16ARRAY:\n                            return new Int16Array(buffer);\n                        case TYPE_UINT16ARRAY:\n                            return new Uint16Array(buffer);\n                        case TYPE_INT32ARRAY:\n                            return new Int32Array(buffer);\n                        case TYPE_UINT32ARRAY:\n                            return new Uint32Array(buffer);\n                        case TYPE_FLOAT32ARRAY:\n                            return new Float32Array(buffer);\n                        case TYPE_FLOAT64ARRAY:\n                            return new Float64Array(buffer);\n                        default:\n                            throw new Error(\"Unkown type: \" + type);\n                    }\n                }\n                var localforageSerializer = {\n                    serialize: serialize,\n                    deserialize: deserialize,\n                    stringToBuffer: stringToBuffer,\n                    bufferToString: bufferToString\n                };\n                /*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */ function createDbTable(t, dbInfo, callback, errorCallback) {\n                    t.executeSql(\"CREATE TABLE IF NOT EXISTS \" + dbInfo.storeName + \" \" + \"(id INTEGER PRIMARY KEY, key unique, value)\", [], callback, errorCallback);\n                }\n                // Open the WebSQL database (automatically creates one if one didn't\n                // previously exist), using any options set in the config.\n                function _initStorage$1(options) {\n                    var self1 = this;\n                    var dbInfo = {\n                        db: null\n                    };\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = typeof options[i] !== \"string\" ? options[i].toString() : options[i];\n                        }\n                    }\n                    var dbInfoPromise = new Promise$1(function(resolve, reject) {\n                        // Open the database; the openDatabase API will automatically\n                        // create it for us if it doesn't exist.\n                        try {\n                            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // Create our key/value table if it doesn't exist.\n                        dbInfo.db.transaction(function(t) {\n                            createDbTable(t, dbInfo, function() {\n                                self1._dbInfo = dbInfo;\n                                resolve();\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, reject);\n                    });\n                    dbInfo.serializer = localforageSerializer;\n                    return dbInfoPromise;\n                }\n                function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n                    t.executeSql(sqlStatement, args, callback, function(t, error) {\n                        if (error.code === error.SYNTAX_ERR) {\n                            t.executeSql(\"SELECT name FROM sqlite_master \" + \"WHERE type='table' AND name = ?\", [\n                                dbInfo.storeName\n                            ], function(t, results) {\n                                if (!results.rows.length) {\n                                    // if the table is missing (was deleted)\n                                    // re-create it table and retry\n                                    createDbTable(t, dbInfo, function() {\n                                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                                    }, errorCallback);\n                                } else {\n                                    errorCallback(t, error);\n                                }\n                            }, errorCallback);\n                        } else {\n                            errorCallback(t, error);\n                        }\n                    }, errorCallback);\n                }\n                function getItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName + \" WHERE key = ? LIMIT 1\", [\n                                    key\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).value : null;\n                                    // Check to see if this is serialized content we need to\n                                    // unpack.\n                                    if (result) {\n                                        result = dbInfo.serializer.deserialize(result);\n                                    }\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function iterate$1(iterator, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT * FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var rows = results.rows;\n                                    var length = rows.length;\n                                    for(var i = 0; i < length; i++){\n                                        var item = rows.item(i);\n                                        var result = item.value;\n                                        // Check to see if this is serialized content\n                                        // we need to unpack.\n                                        if (result) {\n                                            result = dbInfo.serializer.deserialize(result);\n                                        }\n                                        result = iterator(result, item.key, i + 1);\n                                        // void(0) prevents problems with redefinition\n                                        // of `undefined`.\n                                        if (result !== void 0) {\n                                            resolve(result);\n                                            return;\n                                        }\n                                    }\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function _setItem(key, value, callback, retriesLeft) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            // The localStorage API doesn't return undefined values in an\n                            // \"expected\" way, so undefined is always cast to null in all\n                            // drivers. See: https://github.com/mozilla/localForage/pull/42\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            // Save the original value to pass to the callback.\n                            var originalValue = value;\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) {\n                                    reject(error);\n                                } else {\n                                    dbInfo.db.transaction(function(t) {\n                                        tryExecuteSql(t, dbInfo, \"INSERT OR REPLACE INTO \" + dbInfo.storeName + \" \" + \"(key, value) VALUES (?, ?)\", [\n                                            key,\n                                            value\n                                        ], function() {\n                                            resolve(originalValue);\n                                        }, function(t, error) {\n                                            reject(error);\n                                        });\n                                    }, function(sqlError) {\n                                        // The transaction failed; check\n                                        // to see if it's a quota error.\n                                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                                            // We reject the callback outright for now, but\n                                            // it's worth trying to re-run the transaction.\n                                            // Even if the user accepts the prompt to use\n                                            // more storage on Safari, this error will\n                                            // be called.\n                                            //\n                                            // Try to re-run the transaction.\n                                            if (retriesLeft > 0) {\n                                                resolve(_setItem.apply(self1, [\n                                                    key,\n                                                    originalValue,\n                                                    callback,\n                                                    retriesLeft - 1\n                                                ]));\n                                                return;\n                                            }\n                                            reject(sqlError);\n                                        }\n                                    });\n                                }\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function setItem$1(key, value, callback) {\n                    return _setItem.apply(this, [\n                        key,\n                        value,\n                        callback,\n                        1\n                    ]);\n                }\n                function removeItem$1(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName + \" WHERE key = ?\", [\n                                    key\n                                ], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Deletes every item in the table.\n                // TODO: Find out if this resets the AUTO_INCREMENT number.\n                function clear$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"DELETE FROM \" + dbInfo.storeName, [], function() {\n                                    resolve();\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Does a simple `COUNT(key)` to get the number of items stored in\n                // localForage.\n                function length$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                // Ahhh, SQL makes this one soooooo easy.\n                                tryExecuteSql(t, dbInfo, \"SELECT COUNT(key) as c FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var result = results.rows.item(0).c;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Return the key located at key index X; essentially gets the key from a\n                // `WHERE id = ?`. This is the most efficient way I can think to implement\n                // this rarely-used (in my experience) part of the API, but it can seem\n                // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n                // the ID of each key will change every time it's updated. Perhaps a stored\n                // procedure for the `setItem()` SQL would solve this problem?\n                // TODO: Don't change ID on `setItem()`.\n                function key$1(n, callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName + \" WHERE id = ? LIMIT 1\", [\n                                    n + 1\n                                ], function(t, results) {\n                                    var result = results.rows.length ? results.rows.item(0).key : null;\n                                    resolve(result);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$1(callback) {\n                    var self1 = this;\n                    var promise = new Promise$1(function(resolve, reject) {\n                        self1.ready().then(function() {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.db.transaction(function(t) {\n                                tryExecuteSql(t, dbInfo, \"SELECT key FROM \" + dbInfo.storeName, [], function(t, results) {\n                                    var keys = [];\n                                    for(var i = 0; i < results.rows.length; i++){\n                                        keys.push(results.rows.item(i).key);\n                                    }\n                                    resolve(keys);\n                                }, function(t, error) {\n                                    reject(error);\n                                });\n                            });\n                        })[\"catch\"](reject);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // https://www.w3.org/TR/webdatabase/#databases\n                // > There is no way to enumerate or delete the databases available for an origin from this API.\n                function getAllStoreNames(db) {\n                    return new Promise$1(function(resolve, reject) {\n                        db.transaction(function(t) {\n                            t.executeSql(\"SELECT name FROM sqlite_master \" + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function(t, results) {\n                                var storeNames = [];\n                                for(var i = 0; i < results.rows.length; i++){\n                                    storeNames.push(results.rows.item(i).name);\n                                }\n                                resolve({\n                                    db: db,\n                                    storeNames: storeNames\n                                });\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, function(sqlError) {\n                            reject(sqlError);\n                        });\n                    });\n                }\n                function dropInstance$1(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    var currentConfig = this.config();\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        promise = new Promise$1(function(resolve) {\n                            var db;\n                            if (options.name === currentConfig.name) {\n                                // use the db reference of the current instance\n                                db = self1._dbInfo.db;\n                            } else {\n                                db = openDatabase(options.name, \"\", \"\", 0);\n                            }\n                            if (!options.storeName) {\n                                // drop all database tables\n                                resolve(getAllStoreNames(db));\n                            } else {\n                                resolve({\n                                    db: db,\n                                    storeNames: [\n                                        options.storeName\n                                    ]\n                                });\n                            }\n                        }).then(function(operationInfo) {\n                            return new Promise$1(function(resolve, reject) {\n                                operationInfo.db.transaction(function(t) {\n                                    function dropTable(storeName) {\n                                        return new Promise$1(function(resolve, reject) {\n                                            t.executeSql(\"DROP TABLE IF EXISTS \" + storeName, [], function() {\n                                                resolve();\n                                            }, function(t, error) {\n                                                reject(error);\n                                            });\n                                        });\n                                    }\n                                    var operations = [];\n                                    for(var i = 0, len = operationInfo.storeNames.length; i < len; i++){\n                                        operations.push(dropTable(operationInfo.storeNames[i]));\n                                    }\n                                    Promise$1.all(operations).then(function() {\n                                        resolve();\n                                    })[\"catch\"](function(e) {\n                                        reject(e);\n                                    });\n                                }, function(sqlError) {\n                                    reject(sqlError);\n                                });\n                            });\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var webSQLStorage = {\n                    _driver: \"webSQLStorage\",\n                    _initStorage: _initStorage$1,\n                    _support: isWebSQLValid(),\n                    iterate: iterate$1,\n                    getItem: getItem$1,\n                    setItem: setItem$1,\n                    removeItem: removeItem$1,\n                    clear: clear$1,\n                    length: length$1,\n                    key: key$1,\n                    keys: keys$1,\n                    dropInstance: dropInstance$1\n                };\n                function isLocalStorageValid() {\n                    try {\n                        return typeof localStorage !== \"undefined\" && \"setItem\" in localStorage && // in IE8 typeof localStorage.setItem === 'object'\n                        !!localStorage.setItem;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getKeyPrefix(options, defaultConfig) {\n                    var keyPrefix = options.name + \"/\";\n                    if (options.storeName !== defaultConfig.storeName) {\n                        keyPrefix += options.storeName + \"/\";\n                    }\n                    return keyPrefix;\n                }\n                // Check if localStorage throws when saving an item\n                function checkIfLocalStorageThrows() {\n                    var localStorageTestKey = \"_localforage_support_test\";\n                    try {\n                        localStorage.setItem(localStorageTestKey, true);\n                        localStorage.removeItem(localStorageTestKey);\n                        return false;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n                // Check if localStorage is usable and allows to save an item\n                // This method checks if localStorage is usable in Safari Private Browsing\n                // mode, or in any other case where the available quota for localStorage\n                // is 0 and there wasn't any saved items yet.\n                function _isLocalStorageUsable() {\n                    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n                }\n                // Config the localStorage backend, using options set in the config.\n                function _initStorage$2(options) {\n                    var self1 = this;\n                    var dbInfo = {};\n                    if (options) {\n                        for(var i in options){\n                            dbInfo[i] = options[i];\n                        }\n                    }\n                    dbInfo.keyPrefix = _getKeyPrefix(options, self1._defaultConfig);\n                    if (!_isLocalStorageUsable()) {\n                        return Promise$1.reject();\n                    }\n                    self1._dbInfo = dbInfo;\n                    dbInfo.serializer = localforageSerializer;\n                    return Promise$1.resolve();\n                }\n                // Remove all keys from the datastore, effectively destroying all data in\n                // the app's key/value store!\n                function clear$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var keyPrefix = self1._dbInfo.keyPrefix;\n                        for(var i = localStorage.length - 1; i >= 0; i--){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) === 0) {\n                                localStorage.removeItem(key);\n                            }\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Retrieve an item from the store. Unlike the original async_storage\n                // library in Gaia, we don't modify return values at all. If a key's value\n                // is `undefined`, we pass that value to the callback function.\n                function getItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n                        // If a result was found, parse it from the serialized\n                        // string into a JS object. If result isn't truthy, the key\n                        // is likely undefined and we'll pass it straight to the\n                        // callback.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Iterate over all items in the store.\n                function iterate$2(iterator, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var keyPrefix = dbInfo.keyPrefix;\n                        var keyPrefixLength = keyPrefix.length;\n                        var length = localStorage.length;\n                        // We use a dedicated iterator instead of the `i` variable below\n                        // so other keys we fetch in localStorage aren't counted in\n                        // the `iterationNumber` argument passed to the `iterate()`\n                        // callback.\n                        //\n                        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n                        var iterationNumber = 1;\n                        for(var i = 0; i < length; i++){\n                            var key = localStorage.key(i);\n                            if (key.indexOf(keyPrefix) !== 0) {\n                                continue;\n                            }\n                            var value = localStorage.getItem(key);\n                            // If a result was found, parse it from the serialized\n                            // string into a JS object. If result isn't truthy, the\n                            // key is likely undefined and we'll pass it straight\n                            // to the iterator.\n                            if (value) {\n                                value = dbInfo.serializer.deserialize(value);\n                            }\n                            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n                            if (value !== void 0) {\n                                return value;\n                            }\n                        }\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Same as localStorage's key() method, except takes a callback.\n                function key$2(n, callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var result;\n                        try {\n                            result = localStorage.key(n);\n                        } catch (error) {\n                            result = null;\n                        }\n                        // Remove the prefix from the key, if a key is found.\n                        if (result) {\n                            result = result.substring(dbInfo.keyPrefix.length);\n                        }\n                        return result;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function keys$2(callback) {\n                    var self1 = this;\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        var length = localStorage.length;\n                        var keys = [];\n                        for(var i = 0; i < length; i++){\n                            var itemKey = localStorage.key(i);\n                            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n                            }\n                        }\n                        return keys;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Supply the number of keys in the datastore to the callback function.\n                function length$2(callback) {\n                    var self1 = this;\n                    var promise = self1.keys().then(function(keys) {\n                        return keys.length;\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Remove an item from the store, nice and simple.\n                function removeItem$2(key, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        var dbInfo = self1._dbInfo;\n                        localStorage.removeItem(dbInfo.keyPrefix + key);\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                // Set a key's value and run an optional callback once the value is set.\n                // Unlike Gaia's implementation, the callback function is passed the value,\n                // in case you want to operate on that value only after you're sure it\n                // saved, or something like that.\n                function setItem$2(key, value, callback) {\n                    var self1 = this;\n                    key = normalizeKey(key);\n                    var promise = self1.ready().then(function() {\n                        // Convert undefined values to null.\n                        // https://github.com/mozilla/localForage/pull/42\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        // Save the original value to pass to the callback.\n                        var originalValue = value;\n                        return new Promise$1(function(resolve, reject) {\n                            var dbInfo = self1._dbInfo;\n                            dbInfo.serializer.serialize(value, function(value, error) {\n                                if (error) {\n                                    reject(error);\n                                } else {\n                                    try {\n                                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                                        resolve(originalValue);\n                                    } catch (e) {\n                                        // localStorage capacity exceeded.\n                                        // TODO: Make this a specific error/event.\n                                        if (e.name === \"QuotaExceededError\" || e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") {\n                                            reject(e);\n                                        }\n                                        reject(e);\n                                    }\n                                }\n                            });\n                        });\n                    });\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                function dropInstance$2(options, callback) {\n                    callback = getCallback.apply(this, arguments);\n                    options = typeof options !== \"function\" && options || {};\n                    if (!options.name) {\n                        var currentConfig = this.config();\n                        options.name = options.name || currentConfig.name;\n                        options.storeName = options.storeName || currentConfig.storeName;\n                    }\n                    var self1 = this;\n                    var promise;\n                    if (!options.name) {\n                        promise = Promise$1.reject(\"Invalid arguments\");\n                    } else {\n                        promise = new Promise$1(function(resolve) {\n                            if (!options.storeName) {\n                                resolve(options.name + \"/\");\n                            } else {\n                                resolve(_getKeyPrefix(options, self1._defaultConfig));\n                            }\n                        }).then(function(keyPrefix) {\n                            for(var i = localStorage.length - 1; i >= 0; i--){\n                                var key = localStorage.key(i);\n                                if (key.indexOf(keyPrefix) === 0) {\n                                    localStorage.removeItem(key);\n                                }\n                            }\n                        });\n                    }\n                    executeCallback(promise, callback);\n                    return promise;\n                }\n                var localStorageWrapper = {\n                    _driver: \"localStorageWrapper\",\n                    _initStorage: _initStorage$2,\n                    _support: isLocalStorageValid(),\n                    iterate: iterate$2,\n                    getItem: getItem$2,\n                    setItem: setItem$2,\n                    removeItem: removeItem$2,\n                    clear: clear$2,\n                    length: length$2,\n                    key: key$2,\n                    keys: keys$2,\n                    dropInstance: dropInstance$2\n                };\n                var sameValue = function sameValue(x, y) {\n                    return x === y || typeof x === \"number\" && typeof y === \"number\" && isNaN(x) && isNaN(y);\n                };\n                var includes = function includes(array, searchElement) {\n                    var len = array.length;\n                    var i = 0;\n                    while(i < len){\n                        if (sameValue(array[i], searchElement)) {\n                            return true;\n                        }\n                        i++;\n                    }\n                    return false;\n                };\n                var isArray = Array.isArray || function(arg) {\n                    return Object.prototype.toString.call(arg) === \"[object Array]\";\n                };\n                // Drivers are stored here when `defineDriver()` is called.\n                // They are shared across all instances of localForage.\n                var DefinedDrivers = {};\n                var DriverSupport = {};\n                var DefaultDrivers = {\n                    INDEXEDDB: asyncStorage,\n                    WEBSQL: webSQLStorage,\n                    LOCALSTORAGE: localStorageWrapper\n                };\n                var DefaultDriverOrder = [\n                    DefaultDrivers.INDEXEDDB._driver,\n                    DefaultDrivers.WEBSQL._driver,\n                    DefaultDrivers.LOCALSTORAGE._driver\n                ];\n                var OptionalDriverMethods = [\n                    \"dropInstance\"\n                ];\n                var LibraryMethods = [\n                    \"clear\",\n                    \"getItem\",\n                    \"iterate\",\n                    \"key\",\n                    \"keys\",\n                    \"length\",\n                    \"removeItem\",\n                    \"setItem\"\n                ].concat(OptionalDriverMethods);\n                var DefaultConfig = {\n                    description: \"\",\n                    driver: DefaultDriverOrder.slice(),\n                    name: \"localforage\",\n                    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n                    // we can use without a prompt.\n                    size: 4980736,\n                    storeName: \"keyvaluepairs\",\n                    version: 1.0\n                };\n                function callWhenReady(localForageInstance, libraryMethod) {\n                    localForageInstance[libraryMethod] = function() {\n                        var _args = arguments;\n                        return localForageInstance.ready().then(function() {\n                            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n                        });\n                    };\n                }\n                function extend() {\n                    for(var i = 1; i < arguments.length; i++){\n                        var arg = arguments[i];\n                        if (arg) {\n                            for(var _key in arg){\n                                if (arg.hasOwnProperty(_key)) {\n                                    if (isArray(arg[_key])) {\n                                        arguments[0][_key] = arg[_key].slice();\n                                    } else {\n                                        arguments[0][_key] = arg[_key];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return arguments[0];\n                }\n                var LocalForage = function() {\n                    function LocalForage(options) {\n                        _classCallCheck(this, LocalForage);\n                        for(var driverTypeKey in DefaultDrivers){\n                            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                                var driver = DefaultDrivers[driverTypeKey];\n                                var driverName = driver._driver;\n                                this[driverTypeKey] = driverName;\n                                if (!DefinedDrivers[driverName]) {\n                                    // we don't need to wait for the promise,\n                                    // since the default drivers can be defined\n                                    // in a blocking manner\n                                    this.defineDriver(driver);\n                                }\n                            }\n                        }\n                        this._defaultConfig = extend({}, DefaultConfig);\n                        this._config = extend({}, this._defaultConfig, options);\n                        this._driverSet = null;\n                        this._initDriver = null;\n                        this._ready = false;\n                        this._dbInfo = null;\n                        this._wrapLibraryMethodsWithReady();\n                        this.setDriver(this._config.driver)[\"catch\"](function() {});\n                    }\n                    // Set any config values for localForage; can be called anytime before\n                    // the first API call (e.g. `getItem`, `setItem`).\n                    // We loop through options so we don't overwrite existing config\n                    // values.\n                    LocalForage.prototype.config = function config(options) {\n                        // If the options argument is an object, we use it to set values.\n                        // Otherwise, we return either a specified config value or all\n                        // config values.\n                        if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\") {\n                            // If localforage is ready and fully initialized, we can't set\n                            // any new configuration values. Instead, we return an error.\n                            if (this._ready) {\n                                return new Error(\"Can't call config() after localforage \" + \"has been used.\");\n                            }\n                            for(var i in options){\n                                if (i === \"storeName\") {\n                                    options[i] = options[i].replace(/\\W/g, \"_\");\n                                }\n                                if (i === \"version\" && typeof options[i] !== \"number\") {\n                                    return new Error(\"Database version must be a number.\");\n                                }\n                                this._config[i] = options[i];\n                            }\n                            // after all config options are set and\n                            // the driver option is used, try setting it\n                            if (\"driver\" in options && options.driver) {\n                                return this.setDriver(this._config.driver);\n                            }\n                            return true;\n                        } else if (typeof options === \"string\") {\n                            return this._config[options];\n                        } else {\n                            return this._config;\n                        }\n                    };\n                    // Used to define a custom driver, shared across all instances of\n                    // localForage.\n                    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n                        var promise = new Promise$1(function(resolve, reject) {\n                            try {\n                                var driverName = driverObject._driver;\n                                var complianceError = new Error(\"Custom driver not compliant; see \" + \"https://mozilla.github.io/localForage/#definedriver\");\n                                // A driver name should be defined and not overlap with the\n                                // library-defined, default drivers.\n                                if (!driverObject._driver) {\n                                    reject(complianceError);\n                                    return;\n                                }\n                                var driverMethods = LibraryMethods.concat(\"_initStorage\");\n                                for(var i = 0, len = driverMethods.length; i < len; i++){\n                                    var driverMethodName = driverMethods[i];\n                                    // when the property is there,\n                                    // it should be a method even when optional\n                                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== \"function\") {\n                                        reject(complianceError);\n                                        return;\n                                    }\n                                }\n                                var configureMissingMethods = function configureMissingMethods() {\n                                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                                        return function() {\n                                            var error = new Error(\"Method \" + methodName + \" is not implemented by the current driver\");\n                                            var promise = Promise$1.reject(error);\n                                            executeCallback(promise, arguments[arguments.length - 1]);\n                                            return promise;\n                                        };\n                                    };\n                                    for(var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++){\n                                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                                        if (!driverObject[optionalDriverMethod]) {\n                                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                                        }\n                                    }\n                                };\n                                configureMissingMethods();\n                                var setDriverSupport = function setDriverSupport(support) {\n                                    if (DefinedDrivers[driverName]) {\n                                        console.info(\"Redefining LocalForage driver: \" + driverName);\n                                    }\n                                    DefinedDrivers[driverName] = driverObject;\n                                    DriverSupport[driverName] = support;\n                                    // don't use a then, so that we can define\n                                    // drivers that have simple _support methods\n                                    // in a blocking manner\n                                    resolve();\n                                };\n                                if (\"_support\" in driverObject) {\n                                    if (driverObject._support && typeof driverObject._support === \"function\") {\n                                        driverObject._support().then(setDriverSupport, reject);\n                                    } else {\n                                        setDriverSupport(!!driverObject._support);\n                                    }\n                                } else {\n                                    setDriverSupport(true);\n                                }\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                        executeTwoCallbacks(promise, callback, errorCallback);\n                        return promise;\n                    };\n                    LocalForage.prototype.driver = function driver() {\n                        return this._driver || null;\n                    };\n                    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n                        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error(\"Driver not found.\"));\n                        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n                        return getDriverPromise;\n                    };\n                    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n                        var serializerPromise = Promise$1.resolve(localforageSerializer);\n                        executeTwoCallbacks(serializerPromise, callback);\n                        return serializerPromise;\n                    };\n                    LocalForage.prototype.ready = function ready(callback) {\n                        var self1 = this;\n                        var promise = self1._driverSet.then(function() {\n                            if (self1._ready === null) {\n                                self1._ready = self1._initDriver();\n                            }\n                            return self1._ready;\n                        });\n                        executeTwoCallbacks(promise, callback, callback);\n                        return promise;\n                    };\n                    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n                        var self1 = this;\n                        if (!isArray(drivers)) {\n                            drivers = [\n                                drivers\n                            ];\n                        }\n                        var supportedDrivers = this._getSupportedDrivers(drivers);\n                        function setDriverToConfig() {\n                            self1._config.driver = self1.driver();\n                        }\n                        function extendSelfWithDriver(driver) {\n                            self1._extend(driver);\n                            setDriverToConfig();\n                            self1._ready = self1._initStorage(self1._config);\n                            return self1._ready;\n                        }\n                        function initDriver(supportedDrivers) {\n                            return function() {\n                                var currentDriverIndex = 0;\n                                function driverPromiseLoop() {\n                                    while(currentDriverIndex < supportedDrivers.length){\n                                        var driverName = supportedDrivers[currentDriverIndex];\n                                        currentDriverIndex++;\n                                        self1._dbInfo = null;\n                                        self1._ready = null;\n                                        return self1.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                                    }\n                                    setDriverToConfig();\n                                    var error = new Error(\"No available storage method found.\");\n                                    self1._driverSet = Promise$1.reject(error);\n                                    return self1._driverSet;\n                                }\n                                return driverPromiseLoop();\n                            };\n                        }\n                        // There might be a driver initialization in progress\n                        // so wait for it to finish in order to avoid a possible\n                        // race condition to set _dbInfo\n                        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function() {\n                            return Promise$1.resolve();\n                        }) : Promise$1.resolve();\n                        this._driverSet = oldDriverSetDone.then(function() {\n                            var driverName = supportedDrivers[0];\n                            self1._dbInfo = null;\n                            self1._ready = null;\n                            return self1.getDriver(driverName).then(function(driver) {\n                                self1._driver = driver._driver;\n                                setDriverToConfig();\n                                self1._wrapLibraryMethodsWithReady();\n                                self1._initDriver = initDriver(supportedDrivers);\n                            });\n                        })[\"catch\"](function() {\n                            setDriverToConfig();\n                            var error = new Error(\"No available storage method found.\");\n                            self1._driverSet = Promise$1.reject(error);\n                            return self1._driverSet;\n                        });\n                        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n                        return this._driverSet;\n                    };\n                    LocalForage.prototype.supports = function supports(driverName) {\n                        return !!DriverSupport[driverName];\n                    };\n                    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n                        extend(this, libraryMethodsAndProperties);\n                    };\n                    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n                        var supportedDrivers = [];\n                        for(var i = 0, len = drivers.length; i < len; i++){\n                            var driverName = drivers[i];\n                            if (this.supports(driverName)) {\n                                supportedDrivers.push(driverName);\n                            }\n                        }\n                        return supportedDrivers;\n                    };\n                    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n                        // Add a stub for each driver API method that delays the call to the\n                        // corresponding driver method until localForage is ready. These stubs\n                        // will be replaced by the driver methods as soon as the driver is\n                        // loaded, so there is no performance impact.\n                        for(var i = 0, len = LibraryMethods.length; i < len; i++){\n                            callWhenReady(this, LibraryMethods[i]);\n                        }\n                    };\n                    LocalForage.prototype.createInstance = function createInstance(options) {\n                        return new LocalForage(options);\n                    };\n                    return LocalForage;\n                }();\n                // The actual localForage object that we expose as a module or via a\n                // global. It's extended by pulling in one of our other libraries.\n                var localforage_js = new LocalForage();\n                module1.exports = localforage_js;\n            },\n            {\n                \"3\": 3\n            }\n        ]\n    }, {}, [\n        4\n    ])(4);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9jYWxmb3JhZ2UvZGlzdC9sb2NhbGZvcmFnZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0FBS0EsR0FDQyxVQUFTQSxDQUFDO0lBQUUsSUFBRyxJQUFzRCxFQUFDO1FBQUNFLE9BQU9ELE9BQU8sR0FBQ0Q7SUFBRyxPQUFNLFVBQW9PO0FBQUEsR0FBRztJQUFXLElBQUlHLFNBQU9ELFNBQU9EO0lBQVEsT0FBTyxDQUFDLFNBQVNTLEVBQUVDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsU0FBU0MsRUFBRUMsQ0FBQyxFQUFDQyxDQUFDO1lBQUUsSUFBRyxDQUFDSixDQUFDLENBQUNHLEVBQUUsRUFBQztnQkFBQyxJQUFHLENBQUNKLENBQUMsQ0FBQ0ksRUFBRSxFQUFDO29CQUFDLElBQUlFLElBQUUsU0FBbUNDO29CQUFDLElBQUcsQ0FBQ0YsS0FBR0MsR0FBRSxPQUFPQSxPQUFDQSxDQUFDRixHQUFFLENBQUM7b0JBQUcsSUFBR0ksR0FBRSxPQUFPQSxFQUFFSixHQUFFLENBQUM7b0JBQUcsSUFBSWYsSUFBRSxJQUFJb0IsTUFBTSx5QkFBdUJMLElBQUU7b0JBQUssTUFBT2YsRUFBRXFCLElBQUksR0FBQyxvQkFBb0JyQjtnQkFBRTtnQkFBQyxJQUFJc0IsSUFBRVYsQ0FBQyxDQUFDRyxFQUFFLEdBQUM7b0JBQUNkLFNBQVEsQ0FBQztnQkFBQztnQkFBRVUsQ0FBQyxDQUFDSSxFQUFFLENBQUMsRUFBRSxDQUFDUSxJQUFJLENBQUNELEVBQUVyQixPQUFPLEVBQUMsU0FBU1MsQ0FBQztvQkFBRSxJQUFJRSxJQUFFRCxDQUFDLENBQUNJLEVBQUUsQ0FBQyxFQUFFLENBQUNMLEVBQUU7b0JBQUMsT0FBT0ksRUFBRUYsSUFBRUEsSUFBRUY7Z0JBQUUsR0FBRVksR0FBRUEsRUFBRXJCLE9BQU8sRUFBQ1MsR0FBRUMsR0FBRUMsR0FBRUM7WUFBRTtZQUFDLE9BQU9ELENBQUMsQ0FBQ0csRUFBRSxDQUFDZCxPQUFP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QUs7NEJBQ2hELElBQUlpYSxhQUFhMkIsT0FBTyxDQUFDNWIsRUFBRTs0QkFDM0IsSUFBSSxJQUFJLENBQUNzYyxRQUFRLENBQUNyQyxhQUFhO2dDQUMzQjRCLGlCQUFpQnBaLElBQUksQ0FBQ3dYOzRCQUMxQjt3QkFDSjt3QkFDQSxPQUFPNEI7b0JBQ1g7b0JBRUE5QixZQUFZMVcsU0FBUyxDQUFDa1gsNEJBQTRCLEdBQUcsU0FBU0E7d0JBQzFELG9FQUFvRTt3QkFDcEUsc0VBQXNFO3dCQUN0RSxrRUFBa0U7d0JBQ2xFLDZDQUE2Qzt3QkFDN0MsSUFBSyxJQUFJdmEsSUFBSSxHQUFHc0MsTUFBTThXLGVBQWUvWSxNQUFNLEVBQUVMLElBQUlzQyxLQUFLdEMsSUFBSzs0QkFDdkR3WixjQUFjLElBQUksRUFBRUosY0FBYyxDQUFDcFosRUFBRTt3QkFDekM7b0JBQ0o7b0JBRUErWixZQUFZMVcsU0FBUyxDQUFDbVosY0FBYyxHQUFHLFNBQVNBLGVBQWUzTixPQUFPO3dCQUNsRSxPQUFPLElBQUlrTCxZQUFZbEw7b0JBQzNCO29CQUVBLE9BQU9rTDtnQkFDWDtnQkFFQSxvRUFBb0U7Z0JBQ3BFLGtFQUFrRTtnQkFHbEUsSUFBSTBDLGlCQUFpQixJQUFJMUM7Z0JBRXpCaGIsUUFBT0QsT0FBTyxHQUFHMmQ7WUFFakI7WUFBRTtnQkFBQyxLQUFJO1lBQUM7U0FBRTtJQUFBLEdBQUUsQ0FBQyxHQUFFO1FBQUM7S0FBRSxFQUFFO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVyZGlmaWVkLWNsaWVudC8uL25vZGVfbW9kdWxlcy9sb2NhbGZvcmFnZS9kaXN0L2xvY2FsZm9yYWdlLmpzP2Y4OTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICAgbG9jYWxGb3JhZ2UgLS0gT2ZmbGluZSBTdG9yYWdlLCBJbXByb3ZlZFxuICAgIFZlcnNpb24gMS4xMC4wXG4gICAgaHR0cHM6Ly9sb2NhbGZvcmFnZS5naXRodWIuaW8vbG9jYWxGb3JhZ2VcbiAgICAoYykgMjAxMy0yMDE3IE1vemlsbGEsIEFwYWNoZSBMaWNlbnNlIDIuMFxuKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmxvY2FsZm9yYWdlID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IChmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGYpfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbnZhciBzY2hlZHVsZURyYWluO1xuXG57XG4gIGlmIChNdXRhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihuZXh0VGljayk7XG4gICAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0VGljaztcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgIHZhciBzY3JpcHRFbCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soKTtcblxuICAgICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHRFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgc2NyaXB0RWwgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2ssIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgaWYgKHF1ZXVlLnB1c2godGFzaykgPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVEcmFpbigpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgaW1tZWRpYXRlID0gX2RlcmVxXygxKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmZ1bmN0aW9uIFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkO1xuICAgIHRoaXMuY2FsbEZ1bGZpbGxlZCA9IHRoaXMub3RoZXJDYWxsRnVsZmlsbGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgdGhpcy5jYWxsUmVqZWN0ZWQgPSB0aGlzLm90aGVyQ2FsbFJlamVjdGVkO1xuICB9XG59XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVzb2x2ZSh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vblJlamVjdGVkLCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB1bndyYXAocHJvbWlzZSwgZnVuYywgdmFsdWUpIHtcbiAgaW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBwcm9taXNlKSB7XG4gICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuaGFuZGxlcnMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBoYW5kbGVycy5yZWplY3Qoc2VsZiwgcmVzdWx0LnZhbHVlKTtcbiAgfVxuICB2YXIgdGhlbmFibGUgPSByZXN1bHQudmFsdWU7XG5cbiAgaWYgKHRoZW5hYmxlKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmhhbmRsZXJzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcHlUaGVuKCkge1xuICAgICAgdGhlbi5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpIHtcbiAgLy8gRWl0aGVyIGZ1bGZpbGwsIHJlamVjdCBvciByZWplY3Qgd2l0aCBlcnJvclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uRXJyb3IodmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVqZWN0KHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvVW53cmFwKCkge1xuICAgIHRoZW5hYmxlKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godHJ5VG9VbndyYXApO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIG9uRXJyb3IocmVzdWx0LnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYXRjaChmdW5jLCB2YWx1ZSkge1xuICB2YXIgb3V0ID0ge307XG4gIHRyeSB7XG4gICAgb3V0LnZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgb3V0LnN0YXR1cyA9ICdzdWNjZXNzJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dC5zdGF0dXMgPSAnZXJyb3InO1xuICAgIG91dC52YWx1ZSA9IGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgdGhpcyhJTlRFUk5BTCksIHZhbHVlKTtcbn1cblxuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFsbFJlc29sdmVyKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gYWxsUmVzb2x2ZXIodmFsdWUsIGkpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYmICFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzb2x2ZXIoaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiByZXNvbHZlcih2YWx1ZSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG59LHtcIjFcIjoxfV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5pZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gIGdsb2JhbC5Qcm9taXNlID0gX2RlcmVxXygyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIjJcIjoyfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gZ2V0SURCKCkge1xuICAgIC8qIGdsb2JhbCBpbmRleGVkREIsd2Via2l0SW5kZXhlZERCLG1vekluZGV4ZWREQixPSW5kZXhlZERCLG1zSW5kZXhlZERCICovXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmtpdEluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1vekluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3pJbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBPSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9JbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtc0luZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtc0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxudmFyIGlkYiA9IGdldElEQigpO1xuXG5mdW5jdGlvbiBpc0luZGV4ZWREQlZhbGlkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgSW5kZXhlZERCOyBmYWxsIGJhY2sgdG8gdmVuZG9yLXByZWZpeGVkIHZlcnNpb25zXG4gICAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCFpZGIgfHwgIWlkYi5vcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbWltaWMgUG91Y2hEQiBoZXJlO1xuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB0ZXN0IGZvciBvcGVuRGF0YWJhc2UgYmVjYXVzZSBJRSBNb2JpbGUgaWRlbnRpZmllcyBpdHNlbGZcbiAgICAgICAgLy8gYXMgU2FmYXJpLiBPaCB0aGUgbHVsei4uLlxuICAgICAgICB2YXIgaXNTYWZhcmkgPSB0eXBlb2Ygb3BlbkRhdGFiYXNlICE9PSAndW5kZWZpbmVkJyAmJiAvKFNhZmFyaXxpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0JsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuICAgICAgICB2YXIgaGFzRmV0Y2ggPSB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgZmV0Y2gudG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGUnKSAhPT0gLTE7XG5cbiAgICAgICAgLy8gU2FmYXJpIDwxMC4xIGRvZXMgbm90IG1lZXQgb3VyIHJlcXVpcmVtZW50cyBmb3IgSURCIHN1cHBvcnRcbiAgICAgICAgLy8gKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9pc3N1ZXMvNTU3MikuXG4gICAgICAgIC8vIFNhZmFyaSAxMC4xIHNoaXBwZWQgd2l0aCBmZXRjaCwgd2UgY2FuIHVzZSB0aGF0IHRvIGRldGVjdCBpdC5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBjcmVhdGVzIGlzc3VlcyB3aXRoIGB3aW5kb3cuZmV0Y2hgIHBvbHlmaWxscyBhbmRcbiAgICAgICAgLy8gb3ZlcnJpZGVzOyBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2NhbEZvcmFnZS9sb2NhbEZvcmFnZS9pc3N1ZXMvODU2XG4gICAgICAgIHJldHVybiAoIWlzU2FmYXJpIHx8IGhhc0ZldGNoKSAmJiB0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIG91dGRhdGVkIGltcGxlbWVudGF0aW9ucyBvZiBJREIgdGhhdCBhcHBlYXIgb24gU2Ftc3VuZ1xuICAgICAgICAvLyBhbmQgSFRDIEFuZHJvaWQgZGV2aWNlcyA8NC40IGFyZSBtaXNzaW5nIElEQktleVJhbmdlXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzEyOFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8yNzJcbiAgICAgICAgdHlwZW9mIElEQktleVJhbmdlICE9PSAndW5kZWZpbmVkJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIEFic3RyYWN0cyBjb25zdHJ1Y3RpbmcgYSBCbG9iIG9iamVjdCwgc28gaXQgYWxzbyB3b3JrcyBpbiBvbGRlclxuLy8gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgQmxvYiBjb25zdHJ1Y3Rvci4gKGkuZS5cbi8vIG9sZCBRdFdlYktpdCB2ZXJzaW9ucywgYXQgbGVhc3QpLlxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG5mdW5jdGlvbiBjcmVhdGVCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgLyogZ2xvYmFsIEJsb2JCdWlsZGVyLE1TQmxvYkJ1aWxkZXIsTW96QmxvYkJ1aWxkZXIsV2ViS2l0QmxvYkJ1aWxkZXIgKi9cbiAgICBwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihwYXJ0cywgcHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6IHR5cGVvZiBNU0Jsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1TQmxvYkJ1aWxkZXIgOiB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBXZWJLaXRCbG9iQnVpbGRlcjtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYihwcm9wZXJ0aWVzLnR5cGUpO1xuICAgIH1cbn1cblxuLy8gVGhpcyBpcyBDb21tb25KUyBiZWNhdXNlIGxpZSBpcyBhbiBleHRlcm5hbCBkZXBlbmRlbmN5LCBzbyBSb2xsdXBcbi8vIGNhbiBqdXN0IGlnbm9yZSBpdC5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJbiB0aGUgXCJub3Byb21pc2VzXCIgYnVpbGQgdGhpcyB3aWxsIGp1c3QgdGhyb3cgaWYgeW91IGRvbid0IGhhdmVcbiAgICAvLyBhIGdsb2JhbCBwcm9taXNlIG9iamVjdCwgYnV0IGl0IHdvdWxkIHRocm93IGFueXdheSBsYXRlci5cbiAgICBfZGVyZXFfKDMpO1xufVxudmFyIFByb21pc2UkMSA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZVtcImNhdGNoXCJdKGVycm9yQ2FsbGJhY2spO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIC8vIENhc3QgdGhlIGtleSB0byBhIHN0cmluZywgYXMgdGhhdCdzIGFsbCB3ZSBjYW4gc2V0IGFzIGEga2V5LlxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJyB1c2VkIGFzIGEga2V5LCBidXQgaXQgaXMgbm90IGEgc3RyaW5nLicpO1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBnZXRDYWxsYmFjaygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG5cbi8vIFNvbWUgY29kZSBvcmlnaW5hbGx5IGZyb20gYXN5bmNfc3RvcmFnZS5qcyBpblxuLy8gW0dhaWFdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhLWIyZy9nYWlhKS5cblxudmFyIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUgPSAnbG9jYWwtZm9yYWdlLWRldGVjdC1ibG9iLXN1cHBvcnQnO1xudmFyIHN1cHBvcnRzQmxvYnMgPSB2b2lkIDA7XG52YXIgZGJDb250ZXh0cyA9IHt9O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gVHJhbnNhY3Rpb24gTW9kZXNcbnZhciBSRUFEX09OTFkgPSAncmVhZG9ubHknO1xudmFyIFJFQURfV1JJVEUgPSAncmVhZHdyaXRlJztcblxuLy8gVHJhbnNmb3JtIGEgYmluYXJ5IHN0cmluZyB0byBhbiBhcnJheSBidWZmZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlXG4vLyB3ZWlyZCBzdHVmZiBoYXBwZW5zIHdoZW4geW91IHRyeSB0byB3b3JrIHdpdGggdGhlIGJpbmFyeSBzdHJpbmcgZGlyZWN0bHkuXG4vLyBJdCBpcyBrbm93bi5cbi8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDk2NzY0Ny8gKGNvbnRpbnVlcyBvbiBuZXh0IGxpbmUpXG4vLyBlbmNvZGUtZGVjb2RlLWltYWdlLXdpdGgtYmFzZTY0LWJyZWFrcy1pbWFnZSAoMjAxMy0wNC0yMSlcbmZ1bmN0aW9uIF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGJpbikge1xuICAgIHZhciBsZW5ndGggPSBiaW4ubGVuZ3RoO1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuXG4vL1xuLy8gQmxvYnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIHZlcnNpb25zIG9mIEluZGV4ZWREQiwgbm90YWJseVxuLy8gQ2hyb21lIDwzNyBhbmQgQW5kcm9pZCA8NS4gSW4gdGhvc2UgdmVyc2lvbnMsIHN0b3JpbmcgYSBibG9iIHdpbGwgdGhyb3cuXG4vL1xuLy8gVmFyaW91cyBvdGhlciBibG9iIGJ1Z3MgZXhpc3QgaW4gQ2hyb21lIHYzNy00MiAoaW5jbHVzaXZlKS5cbi8vIERldGVjdGluZyB0aGVtIGlzIGV4cGVuc2l2ZSBhbmQgY29uZnVzaW5nIHRvIHVzZXJzLCBhbmQgQ2hyb21lIDM3LTQyXG4vLyBpcyBhdCB2ZXJ5IGxvdyB1c2FnZSB3b3JsZHdpZGUsIHNvIHdlIGRvIGEgaGFja3kgdXNlckFnZW50IGNoZWNrIGluc3RlYWQuXG4vL1xuLy8gY29udGVudC10eXBlIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQwODEyMFxuLy8gNDA0IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzkxNlxuLy8gRmlsZVJlYWRlciBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc4MzZcbi8vXG4vLyBDb2RlIGJvcnJvd2VkIGZyb20gUG91Y2hEQi4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWlkYi9zcmMvYmxvYlN1cHBvcnQuanNcbi8vXG5mdW5jdGlvbiBfY2hlY2tCbG9iU3VwcG9ydFdpdGhvdXRDYWNoaW5nKGlkYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0eG4gPSBpZGIudHJhbnNhY3Rpb24oREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSwgUkVBRF9XUklURSk7XG4gICAgICAgIHZhciBibG9iID0gY3JlYXRlQmxvYihbJyddKTtcbiAgICAgICAgdHhuLm9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpLnB1dChibG9iLCAna2V5Jyk7XG5cbiAgICAgICAgdHhuLm9uYWJvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGFib3J0cyBub3cgaXRzIGR1ZSB0byBub3QgYmVpbmcgYWJsZSB0b1xuICAgICAgICAgICAgLy8gd3JpdGUgdG8gdGhlIGRhdGFiYXNlLCBsaWtlbHkgZHVlIHRvIHRoZSBkaXNrIGJlaW5nIGZ1bGxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEVkZ2UgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvLyk7XG4gICAgICAgICAgICAvLyBNUyBFZGdlIHByZXRlbmRzIHRvIGJlIENocm9tZSA0MjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4NjkzMDElMjh2PXZzLjg1JTI5LmFzcHhcbiAgICAgICAgICAgIHJlc29sdmUobWF0Y2hlZEVkZ2UgfHwgIW1hdGNoZWRDaHJvbWUgfHwgcGFyc2VJbnQobWF0Y2hlZENocm9tZVsxXSwgMTApID49IDQzKTtcbiAgICAgICAgfTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlcnJvciwgc28gYXNzdW1lIHVuc3VwcG9ydGVkXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0KGlkYikge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCbG9icyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZShzdXBwb3J0c0Jsb2JzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzdXBwb3J0c0Jsb2JzID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Jsb2JzO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0ge307XG5cbiAgICBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBFbnF1ZXVlIHRoZSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wdXNoKGRlZmVycmVkT3BlcmF0aW9uKTtcblxuICAgIC8vIENoYWluIGl0cyBwcm9taXNlIHRvIHRoZSBkYXRhYmFzZSByZWFkaW5lc3MuXG4gICAgaWYgKCFkYkNvbnRleHQuZGJSZWFkeSkge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGJDb250ZXh0LmRiUmVhZHkgPSBkYkNvbnRleHQuZGJSZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbykge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlc29sdmUgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9yZWplY3RSZWFkaW5lc3MoZGJJbmZvLCBlcnIpIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBEZXF1ZXVlIGEgZGVmZXJyZWQgb3BlcmF0aW9uLlxuICAgIHZhciBkZWZlcnJlZE9wZXJhdGlvbiA9IGRiQ29udGV4dC5kZWZlcnJlZE9wZXJhdGlvbnMucG9wKCk7XG5cbiAgICAvLyBSZWplY3QgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2dldENvbm5lY3Rpb24oZGJJbmZvLCB1cGdyYWRlTmVlZGVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdIHx8IGNyZWF0ZURiQ29udGV4dCgpO1xuXG4gICAgICAgIGlmIChkYkluZm8uZGIpIHtcbiAgICAgICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgZGJJbmZvLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRiSW5mby5kYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGJBcmdzID0gW2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgZGJBcmdzLnB1c2goZGJJbmZvLnZlcnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wZW5yZXEgPSBpZGIub3Blbi5hcHBseShpZGIsIGRiQXJncyk7XG5cbiAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgIG9wZW5yZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVucmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShkYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub2xkVmVyc2lvbiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGRlZCB3aGVuIHN1cHBvcnQgZm9yIGJsb2Igc2hpbXMgd2FzIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnQ29uc3RyYWludEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgJyBoYXMgYmVlbiB1cGdyYWRlZCBmcm9tIHZlcnNpb24gJyArIGUub2xkVmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZS5uZXdWZXJzaW9uICsgJywgYnV0IHRoZSBzdG9yYWdlIFwiJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBvcGVucmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVqZWN0KG9wZW5yZXEuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5yZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiID0gb3BlbnJlcS5yZXN1bHQ7XG4gICAgICAgICAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSBkYXRhYmFzZSBpcyBtb2RpZmllZCAoZS5nLiBhZGRpbmcgYW4gb2JqZWN0U3RvcmUpIG9yXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlZCAoZXZlbiB3aGVuIGluaXRpYXRlZCBieSBvdGhlciBzZXNzaW9ucyBpbiBkaWZmZXJlbnQgdGFicykuXG4gICAgICAgICAgICAgICAgLy8gQ2xvc2luZyB0aGUgY29ubmVjdGlvbiBoZXJlIHByZXZlbnRzIHRob3NlIG9wZXJhdGlvbnMgZnJvbSBiZWluZyBibG9ja2VkLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhYmFzZSBpcyBhY2Nlc3NlZCBhZ2FpbiBsYXRlciBieSB0aGlzIGluc3RhbmNlLCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVvcGVuZWQgb3IgdGhlIGRhdGFiYXNlIHJlY3JlYXRlZCBhcyBuZWVkZWQuXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRPcmlnaW5hbENvbm5lY3Rpb24oZGJJbmZvKSB7XG4gICAgcmV0dXJuIF9nZXRDb25uZWN0aW9uKGRiSW5mbywgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbykge1xuICAgIHJldHVybiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHRydWUpO1xufVxuXG5mdW5jdGlvbiBfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbywgZGVmYXVsdFZlcnNpb24pIHtcbiAgICBpZiAoIWRiSW5mby5kYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNOZXdTdG9yZSA9ICFkYkluZm8uZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhkYkluZm8uc3RvcmVOYW1lKTtcbiAgICB2YXIgaXNEb3duZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA8IGRiSW5mby5kYi52ZXJzaW9uO1xuICAgIHZhciBpc1VwZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA+IGRiSW5mby5kYi52ZXJzaW9uO1xuXG4gICAgaWYgKGlzRG93bmdyYWRlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJzaW9uIGlzIG5vdCB0aGUgZGVmYXVsdCBvbmVcbiAgICAgICAgLy8gdGhlbiB3YXJuIGZvciBpbXBvc3NpYmxlIGRvd25ncmFkZS5cbiAgICAgICAgaWYgKGRiSW5mby52ZXJzaW9uICE9PSBkZWZhdWx0VmVyc2lvbikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgXCIgY2FuJ3QgYmUgZG93bmdyYWRlZCBmcm9tIHZlcnNpb24gXCIgKyBkYkluZm8uZGIudmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZGJJbmZvLnZlcnNpb24gKyAnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsaWduIHRoZSB2ZXJzaW9ucyB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgZGJJbmZvLnZlcnNpb24gPSBkYkluZm8uZGIudmVyc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNVcGdyYWRlIHx8IGlzTmV3U3RvcmUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0b3JlIGlzIG5ldyB0aGVuIGluY3JlbWVudCB0aGUgdmVyc2lvbiAoaWYgbmVlZGVkKS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gXCJ1cGdyYWRlbmVlZGVkXCIgZXZlbnQgd2hpY2ggaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGEgc3RvcmUuXG4gICAgICAgIGlmIChpc05ld1N0b3JlKSB7XG4gICAgICAgICAgICB2YXIgaW5jVmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgIGlmIChpbmNWZXJzaW9uID4gZGJJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGluY1ZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGVuY29kZSBhIGJsb2IgZm9yIGluZGV4ZWRkYiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBibG9ic1xuZnVuY3Rpb24gX2VuY29kZUJsb2IoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBiYXNlNjQgPSBidG9hKGUudGFyZ2V0LnJlc3VsdCB8fCAnJyk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBfX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2I6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogYmFzZTY0LFxuICAgICAgICAgICAgICAgIHR5cGU6IGJsb2IudHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gICAgfSk7XG59XG5cbi8vIGRlY29kZSBhbiBlbmNvZGVkIGJsb2JcbmZ1bmN0aW9uIF9kZWNvZGVCbG9iKGVuY29kZWRCbG9iKSB7XG4gICAgdmFyIGFycmF5QnVmZiA9IF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGF0b2IoZW5jb2RlZEJsb2IuZGF0YSkpO1xuICAgIHJldHVybiBjcmVhdGVCbG9iKFthcnJheUJ1ZmZdLCB7IHR5cGU6IGVuY29kZWRCbG9iLnR5cGUgfSk7XG59XG5cbi8vIGlzIHRoaXMgb25lIG9mIG91ciBmYW5jeSBlbmNvZGVkIGJsb2JzP1xuZnVuY3Rpb24gX2lzRW5jb2RlZEJsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iO1xufVxuXG4vLyBTcGVjaWFsaXplIHRoZSBkZWZhdWx0IGByZWFkeSgpYCBmdW5jdGlvbiBieSBtYWtpbmcgaXQgZGVwZW5kZW50XG4vLyBvbiB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb25zLiBUaHVzLCB0aGUgZHJpdmVyIHdpbGwgYmUgYWN0dWFsbHlcbi8vIHJlYWR5IHdoZW4gaXQncyBiZWVuIGluaXRpYWxpemVkIChkZWZhdWx0KSAqYW5kKiB0aGVyZSBhcmUgbm8gcGVuZGluZ1xuLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGF0YWJhc2UgKGluaXRpYXRlZCBieSBzb21lIG90aGVyIGluc3RhbmNlcykuXG5mdW5jdGlvbiBfZnVsbHlSZWFkeShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5faW5pdFJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW3NlbGYuX2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAoZGJDb250ZXh0ICYmIGRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGJDb250ZXh0LmRiUmVhZHk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gVHJ5IHRvIGVzdGFibGlzaCBhIG5ldyBkYiBjb25uZWN0aW9uIHRvIHJlcGxhY2UgdGhlXG4vLyBjdXJyZW50IG9uZSB3aGljaCBpcyBicm9rZW4gKGkuZS4gZXhwZXJpZW5jaW5nXG4vLyBJbnZhbGlkU3RhdGVFcnJvciB3aGlsZSBjcmVhdGluZyBhIHRyYW5zYWN0aW9uKS5cbmZ1bmN0aW9uIF90cnlSZWNvbm5lY3QoZGJJbmZvKSB7XG4gICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG5cbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG4gICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgaWYgKGZvcmFnZS5fZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYi5jbG9zZSgpO1xuICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRiSW5mby5kYiA9IG51bGw7XG5cbiAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8pKSB7XG4gICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICByZXR1cm4gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAvLyBzdG9yZSB0aGUgbGF0ZXN0IGRiIHJlZmVyZW5jZVxuICAgICAgICAvLyBpbiBjYXNlIHRoZSBkYiB3YXMgdXBncmFkZWRcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yYWdlc1tpXS5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cblxuLy8gRkYgZG9lc24ndCBsaWtlIFByb21pc2VzIChtaWNyby10YXNrcykgYW5kIElEREIgc3RvcmUgb3BlcmF0aW9ucyxcbi8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgd2l0aCBjYWxsYmFja3NcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uKGRiSW5mbywgbW9kZSwgY2FsbGJhY2ssIHJldHJpZXMpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHJpZXMgPSAxO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IGRiSW5mby5kYi50cmFuc2FjdGlvbihkYkluZm8uc3RvcmVOYW1lLCBtb2RlKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cmllcyA+IDAgJiYgKCFkYkluZm8uZGIgfHwgZXJyLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicgfHwgZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGJJbmZvLmRiIHx8IGVyci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgJiYgIWRiSW5mby5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGRiSW5mby5zdG9yZU5hbWUpICYmIGRiSW5mby52ZXJzaW9uIDw9IGRiSW5mby5kYi52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBkYiB2ZXJzaW9uLCB0byBjcmVhdGUgdGhlIG5ldyBPYmplY3RTdG9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90cnlSZWNvbm5lY3QoZGJJbmZvKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oZGJJbmZvLCBtb2RlLCBjYWxsYmFjaywgcmV0cmllcyAtIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGJDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFJ1bm5pbmcgbG9jYWxGb3JhZ2VzIHNoYXJpbmcgYSBkYXRhYmFzZS5cbiAgICAgICAgZm9yYWdlczogW10sXG4gICAgICAgIC8vIFNoYXJlZCBkYXRhYmFzZS5cbiAgICAgICAgZGI6IG51bGwsXG4gICAgICAgIC8vIERhdGFiYXNlIHJlYWRpbmVzcyAocHJvbWlzZSkuXG4gICAgICAgIGRiUmVhZHk6IG51bGwsXG4gICAgICAgIC8vIERlZmVycmVkIG9wZXJhdGlvbnMgb24gdGhlIGRhdGFiYXNlLlxuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbnM6IFtdXG4gICAgfTtcbn1cblxuLy8gT3BlbiB0aGUgSW5kZXhlZERCIGRhdGFiYXNlIChhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIGlmIG9uZSBkaWRuJ3Rcbi8vIHByZXZpb3VzbHkgZXhpc3QpLCB1c2luZyBhbnkgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7XG4gICAgICAgIGRiOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBkYXRhYmFzZTtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyAuLi5vciBjcmVhdGUgYSBuZXcgY29udGV4dC5cbiAgICBpZiAoIWRiQ29udGV4dCkge1xuICAgICAgICBkYkNvbnRleHQgPSBjcmVhdGVEYkNvbnRleHQoKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyBjb250ZXh0IGluIHRoZSBnbG9iYWwgY29udGFpbmVyLlxuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBpdHNlbGYgYXMgYSBydW5uaW5nIGxvY2FsRm9yYWdlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgZGJDb250ZXh0LmZvcmFnZXMucHVzaChzZWxmKTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIGRlZmF1bHQgYHJlYWR5KClgIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpYWxpemVkIG9uZS5cbiAgICBpZiAoIXNlbGYuX2luaXRSZWFkeSkge1xuICAgICAgICBzZWxmLl9pbml0UmVhZHkgPSBzZWxmLnJlYWR5O1xuICAgICAgICBzZWxmLnJlYWR5ID0gX2Z1bGx5UmVhZHk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIGluaXRpYWxpemF0aW9uIHN0YXRlcyBvZiB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgdmFyIGluaXRQcm9taXNlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaWdub3JlRXJyb3JzKCkge1xuICAgICAgICAvLyBEb24ndCBoYW5kbGUgZXJyb3JzIGhlcmUsXG4gICAgICAgIC8vIGp1c3QgbWFrZXMgc3VyZSByZWxhdGVkIGxvY2FsRm9yYWdlcyBhcmVuJ3QgcGVuZGluZy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYkNvbnRleHQuZm9yYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZGJDb250ZXh0LmZvcmFnZXNbal07XG4gICAgICAgIGlmIChmb3JhZ2UgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHdhaXQgZm9yIGl0c2VsZi4uLlxuICAgICAgICAgICAgaW5pdFByb21pc2VzLnB1c2goZm9yYWdlLl9pbml0UmVhZHkoKVtcImNhdGNoXCJdKGlnbm9yZUVycm9ycykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFrZSBhIHNuYXBzaG90IG9mIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzLnNsaWNlKDApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIG9ubHkgd2hlblxuICAgIC8vIGFsbCB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMgYXJlbid0IHBlbmRpbmcuXG4gICAgcmV0dXJuIFByb21pc2UkMS5hbGwoaW5pdFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiO1xuICAgICAgICAvLyBHZXQgdGhlIGNvbm5lY3Rpb24gb3Igb3BlbiBhIG5ldyBvbmUgd2l0aG91dCB1cGdyYWRlLlxuICAgICAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8sIHNlbGYuX2RlZmF1bHRDb25maWcudmVyc2lvbikpIHtcbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgICAgIC8vIFNoYXJlIHRoZSBmaW5hbCBjb25uZWN0aW9uIGFtb25nc3QgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZm9yYWdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNba107XG4gICAgICAgICAgICBpZiAoZm9yYWdlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VsZiBpcyBhbHJlYWR5IHVwLXRvLWRhdGUuXG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBkYkluZm8uZGI7XG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8udmVyc2lvbiA9IGRiSW5mby52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2RlY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBzdG9yZWQgaW4gZGF0YWJhc2UuXG5mdW5jdGlvbiBpdGVyYXRlKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uTnVtYmVyID0gMTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9kZWNvZGVCbG9iKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yKHZhbHVlLCBjdXJzb3Iua2V5LCBpdGVyYXRpb25OdW1iZXIrKyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpdGVyYXRvciBjYWxsYmFjayByZXR1cm5zIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChub24tYHVuZGVmaW5lZGApIHZhbHVlLCB0aGVuIHdlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlcmF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRiSW5mbztcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnQoZGJJbmZvLmRiKS50aGVuKGZ1bmN0aW9uIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VuY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgX3NhdmVfIG51bGwgaXMgYmVjYXVzZSBJRSAxMCBkb2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0IHNhdmluZyB0aGUgYG51bGxgIHR5cGUgaW4gSW5kZXhlZERCLiBIb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXJvbmljLCBnaXZlbiB0aGUgYnVnIGJlbG93IVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8xNjFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQodmFsdWUsIGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgdG8gdW5kZWZpbmVkIHNvIHRoZSB2YWx1ZSBwYXNzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrL3Byb21pc2UgaXMgdGhlIHNhbWUgYXMgd2hhdCBvbmUgd291bGQgZ2V0IG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYGdldEl0ZW0oKWAgbGF0ZXIuIFRoaXMgbGVhZHMgdG8gc29tZSB3ZWlyZG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzZXRJdGVtKCdmb28nLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGBudWxsYCksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgbXkgZmF1bHQgbG9jYWxTdG9yYWdlIGlzIG91ciBiYXNlbGluZSBhbmQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBHcnVudCB0YXNrIHRvIG1ha2UgdGhpcyBzYWZlIGZvciBJRSBhbmQgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBBbmRyb2lkIChpbmNsdWRpbmcgdGhvc2UgdXNlZCBieSBDb3Jkb3ZhKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgSUUgd29uJ3QgbGlrZSBgLmRlbGV0ZSgpYCBhbmQgd2lsbCBpbnNpc3Qgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYFsnZGVsZXRlJ10oKWAsIGJ1dCB3ZSBoYXZlIGEgYnVpbGQgc3RlcCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGVzIHRoaXMgZm9yIHVzIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWxzbyBiZSBhYm9ydGVkIGlmIHdlJ3ZlIGV4Y2VlZGVkIG91ciBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBjbGVhcihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9XUklURSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZHZhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSB3ZXJlbid0IGVub3VnaCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRoZSBmaXJzdCBrZXksIHJldHVybiBpdCBpZiB0aGF0J3Mgd2hhdCB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc2sgdGhlIGN1cnNvciB0byBza2lwIGFoZWFkIG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3Jkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCBoZXJlLCB3ZSd2ZSBnb3QgdGhlIG50aCBrZXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLm9wZW5LZXlDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc0N1cnJlbnREYiA9IG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lICYmIHNlbGYuX2RiSW5mby5kYjtcblxuICAgICAgICB2YXIgZGJQcm9taXNlID0gaXNDdXJyZW50RGIgPyBQcm9taXNlJDEucmVzb2x2ZShzZWxmLl9kYkluZm8uZGIpIDogX2dldE9yaWdpbmFsQ29ubmVjdGlvbihvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG4gICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcmFnZXNbaV0uX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcERCUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLmRlbGV0ZURhdGFiYXNlKG9wdGlvbnMubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIGFsbCBvcGVuIGNvbm5lY3Rpb25zIGluIG9udmVyc2lvbmNoYW5nZSBoYW5kbGVyIHNob3VsZCBwcmV2ZW50IHRoaXMgc2l0dWF0aW9uLCBidXQgaWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIGdldCBoZXJlLCBpdCBqdXN0IG1lYW5zIHRoZSByZXF1ZXN0IHJlbWFpbnMgcGVuZGluZyAtIGV2ZW50dWFsbHkgaXQgd2lsbCBzdWNjZWVkIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2Ryb3BJbnN0YW5jZSBibG9ja2VkIGZvciBkYXRhYmFzZSBcIicgKyBvcHRpb25zLm5hbWUgKyAnXCIgdW50aWwgYWxsIG9wZW4gY29ubmVjdGlvbnMgYXJlIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BEQlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoX2ZvcmFnZS5fZGJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAoX3JlamVjdFJlYWRpbmVzcyhvcHRpb25zLCBlcnIpIHx8IFByb21pc2UkMS5yZXNvbHZlKCkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBkYlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMob3B0aW9ucy5zdG9yZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3VmVyc2lvbiA9IGRiLnZlcnNpb24gKyAxO1xuXG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8udmVyc2lvbiA9IG5ld1ZlcnNpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BPYmplY3RQcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGIub3BlbihvcHRpb25zLm5hbWUsIG5ld1ZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKG9wdGlvbnMuc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wT2JqZWN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3JhZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvcmFnZTIgPSBmb3JhZ2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZvcmFnZTIuX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoX2ZvcmFnZTIuX2RiSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9yZWplY3RSZWFkaW5lc3Mob3B0aW9ucywgZXJyKSB8fCBQcm9taXNlJDEucmVzb2x2ZSgpKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgYXN5bmNTdG9yYWdlID0ge1xuICAgIF9kcml2ZXI6ICdhc3luY1N0b3JhZ2UnLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlLFxuICAgIF9zdXBwb3J0OiBpc0luZGV4ZWREQlZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSxcbiAgICBnZXRJdGVtOiBnZXRJdGVtLFxuICAgIHNldEl0ZW06IHNldEl0ZW0sXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSxcbiAgICBjbGVhcjogY2xlYXIsXG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAga2V5OiBrZXksXG4gICAga2V5czoga2V5cyxcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZVxufTtcblxuZnVuY3Rpb24gaXNXZWJTUUxWYWxpZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wZW5EYXRhYmFzZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLy8gU2FkbHksIHRoZSBiZXN0IHdheSB0byBzYXZlIGJpbmFyeSBkYXRhIGluIFdlYlNRTC9sb2NhbFN0b3JhZ2UgaXMgc2VyaWFsaXppbmdcbi8vIGl0IHRvIEJhc2U2NCwgc28gdGhpcyBpcyBob3cgd2Ugc3RvcmUgaXQgdG8gcHJldmVudCB2ZXJ5IHN0cmFuZ2UgZXJyb3JzIHdpdGggbGVzc1xuLy8gdmVyYm9zZSB3YXlzIG9mIGJpbmFyeSA8LT4gc3RyaW5nIGRhdGEgc3RvcmFnZS5cbnZhciBCQVNFX0NIQVJTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG52YXIgQkxPQl9UWVBFX1BSRUZJWCA9ICd+fmxvY2FsX2ZvcmFnZV90eXBlfic7XG52YXIgQkxPQl9UWVBFX1BSRUZJWF9SRUdFWCA9IC9efn5sb2NhbF9mb3JhZ2VfdHlwZX4oW15+XSspfi87XG5cbnZhciBTRVJJQUxJWkVEX01BUktFUiA9ICdfX2xmc2NfXzonO1xudmFyIFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCA9IFNFUklBTElaRURfTUFSS0VSLmxlbmd0aDtcblxuLy8gT01HIHRoZSBzZXJpYWxpemF0aW9ucyFcbnZhciBUWVBFX0FSUkFZQlVGRkVSID0gJ2FyYmYnO1xudmFyIFRZUEVfQkxPQiA9ICdibG9iJztcbnZhciBUWVBFX0lOVDhBUlJBWSA9ICdzaTA4JztcbnZhciBUWVBFX1VJTlQ4QVJSQVkgPSAndWkwOCc7XG52YXIgVFlQRV9VSU5UOENMQU1QRURBUlJBWSA9ICd1aWM4JztcbnZhciBUWVBFX0lOVDE2QVJSQVkgPSAnc2kxNic7XG52YXIgVFlQRV9JTlQzMkFSUkFZID0gJ3NpMzInO1xudmFyIFRZUEVfVUlOVDE2QVJSQVkgPSAndXIxNic7XG52YXIgVFlQRV9VSU5UMzJBUlJBWSA9ICd1aTMyJztcbnZhciBUWVBFX0ZMT0FUMzJBUlJBWSA9ICdmbDMyJztcbnZhciBUWVBFX0ZMT0FUNjRBUlJBWSA9ICdmbDY0JztcbnZhciBUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCA9IFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCArIFRZUEVfQVJSQVlCVUZGRVIubGVuZ3RoO1xuXG52YXIgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyKHNlcmlhbGl6ZWRTdHJpbmcpIHtcbiAgICAvLyBGaWxsIHRoZSBzdHJpbmcgaW50byBhIEFycmF5QnVmZmVyLlxuICAgIHZhciBidWZmZXJMZW5ndGggPSBzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAqIDAuNzU7XG4gICAgdmFyIGxlbiA9IHNlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoc2VyaWFsaXplZFN0cmluZ1tzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChzZXJpYWxpemVkU3RyaW5nW3NlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2ldKTtcbiAgICAgICAgZW5jb2RlZDIgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgMV0pO1xuICAgICAgICBlbmNvZGVkMyA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAyXSk7XG4gICAgICAgIGVuY29kZWQ0ID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDNdKTtcblxuICAgICAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4gICAgICAgIGJ5dGVzW3ArK10gPSBlbmNvZGVkMSA8PCAyIHwgZW5jb2RlZDIgPj4gNDtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMiAmIDE1KSA8PCA0IHwgZW5jb2RlZDMgPj4gMjtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMyAmIDMpIDw8IDYgfCBlbmNvZGVkNCAmIDYzO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vLyBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIHN0cmluZyB0byBzdG9yZSwgc2VyaWFsaXplZCwgaW4gdGhlIGJhY2tlbmRcbi8vIHN0b3JhZ2UgbGlicmFyeS5cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICAgIC8vIGJhc2U2NC1hcnJheWJ1ZmZlclxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgdmFyIGJhc2U2NFN0cmluZyA9ICcnO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTWyhieXRlc1tpXSAmIDMpIDw8IDQgfCBieXRlc1tpICsgMV0gPj4gNF07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTWyhieXRlc1tpICsgMV0gJiAxNSkgPDwgMiB8IGJ5dGVzW2kgKyAyXSA+PiA2XTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmIChieXRlcy5sZW5ndGggJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NFN0cmluZyA9IGJhc2U2NFN0cmluZy5zdWJzdHJpbmcoMCwgYmFzZTY0U3RyaW5nLmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMyA9PT0gMSkge1xuICAgICAgICBiYXNlNjRTdHJpbmcgPSBiYXNlNjRTdHJpbmcuc3Vic3RyaW5nKDAsIGJhc2U2NFN0cmluZy5sZW5ndGggLSAyKSArICc9PSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZztcbn1cblxuLy8gU2VyaWFsaXplIGEgdmFsdWUsIGFmdGVyd2FyZHMgZXhlY3V0aW5nIGEgY2FsbGJhY2sgKHdoaWNoIHVzdWFsbHlcbi8vIGluc3RydWN0cyB0aGUgYHNldEl0ZW0oKWAgY2FsbGJhY2svcHJvbWlzZSB0byBiZSBleGVjdXRlZCkuIFRoaXMgaXMgaG93XG4vLyB3ZSBzdG9yZSBiaW5hcnkgZGF0YSB3aXRoIGxvY2FsU3RvcmFnZS5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdmFsdWVUeXBlID0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IHRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IHVzZSBgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcmAgb3Igc3VjaCBoZXJlLCBhcyB0aGVzZVxuICAgIC8vIGNoZWNrcyBmYWlsIHdoZW4gcnVubmluZyB0aGUgdGVzdHMgdXNpbmcgY2FzcGVyLmpzLi4uXG4gICAgLy9cbiAgICAvLyBUT0RPOiBTZWUgd2h5IHRob3NlIHRlc3RzIGZhaWwgYW5kIHVzZSBhIGJldHRlciBzb2x1dGlvbi5cbiAgICBpZiAodmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fCB2YWx1ZS5idWZmZXIgJiYgdG9TdHJpbmckMS5jYWxsKHZhbHVlLmJ1ZmZlcikgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpKSB7XG4gICAgICAgIC8vIENvbnZlcnQgYmluYXJ5IGFycmF5cyB0byBhIHN0cmluZyBhbmQgcHJlZml4IHRoZSBzdHJpbmcgd2l0aFxuICAgICAgICAvLyBhIHNwZWNpYWwgbWFya2VyLlxuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgbWFya2VyID0gU0VSSUFMSVpFRF9NQVJLRVI7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfQVJSQVlCVUZGRVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2YWx1ZS5idWZmZXI7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDhBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UOEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQ4QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDE2QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDE2QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQxNkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfRkxPQVQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfRkxPQVQ2NEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdHlwZSBmb3IgQmluYXJ5QXJyYXknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhtYXJrZXIgKyBidWZmZXJUb1N0cmluZyhidWZmZXIpKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgQmxvYl0nKSB7XG4gICAgICAgIC8vIENvbnZlciB0aGUgYmxvYiB0byBhIGJpbmFyeUFycmF5IGFuZCB0aGVuIHRvIGEgc3RyaW5nLlxuICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBwcmVmaXggZm9yIHRoZSBibG9iIHR5cGUuXG4gICAgICAgICAgICB2YXIgc3RyID0gQkxPQl9UWVBFX1BSRUZJWCArIHZhbHVlLnR5cGUgKyAnficgKyBidWZmZXJUb1N0cmluZyh0aGlzLnJlc3VsdCk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKFNFUklBTElaRURfTUFSS0VSICsgVFlQRV9CTE9CICsgc3RyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGNvbnZlcnQgdmFsdWUgaW50byBhIEpTT04gc3RyaW5nOiBcIiwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRGVzZXJpYWxpemUgZGF0YSB3ZSd2ZSBpbnNlcnRlZCBpbnRvIGEgdmFsdWUgY29sdW1uL2ZpZWxkLiBXZSBwbGFjZVxuLy8gc3BlY2lhbCBtYXJrZXJzIGludG8gb3VyIHN0cmluZ3MgdG8gbWFyayB0aGVtIGFzIGVuY29kZWQ7IHRoaXMgaXNuJ3Rcbi8vIGFzIG5pY2UgYXMgYSBtZXRhIGZpZWxkLCBidXQgaXQncyB0aGUgb25seSBzYW5lIHRoaW5nIHdlIGNhbiBkbyB3aGlsc3Rcbi8vIGtlZXBpbmcgbG9jYWxTdG9yYWdlIHN1cHBvcnQgaW50YWN0LlxuLy9cbi8vIE9mdGVudGltZXMgdGhpcyB3aWxsIGp1c3QgZGVzZXJpYWxpemUgSlNPTiBjb250ZW50LCBidXQgaWYgd2UgaGF2ZSBhXG4vLyBzcGVjaWFsIG1hcmtlciAoU0VSSUFMSVpFRF9NQVJLRVIsIGRlZmluZWQgYWJvdmUpLCB3ZSB3aWxsIGV4dHJhY3Rcbi8vIHNvbWUga2luZCBvZiBhcnJheWJ1ZmZlci9iaW5hcnkgZGF0YS90eXBlZCBhcnJheSBvdXQgb2YgdGhlIHN0cmluZy5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBtYXJrZWQgdGhpcyBzdHJpbmcgYXMgYmVpbmcgc3BlY2lhbGx5IHNlcmlhbGl6ZWQgKGkuZS5cbiAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiBzZXJpYWxpemVkIEpTT04pLCB3ZSBjYW4ganVzdCByZXR1cm4gaXQgYW5kIGJlXG4gICAgLy8gZG9uZSB3aXRoIGl0LlxuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKSAhPT0gU0VSSUFMSVpFRF9NQVJLRVIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBkZWFscyB3aXRoIGRlc2VyaWFsaXppbmcgc29tZSBraW5kIG9mIEJsb2Igb3JcbiAgICAvLyBUeXBlZEFycmF5LiBGaXJzdCB3ZSBzZXBhcmF0ZSBvdXQgdGhlIHR5cGUgb2YgZGF0YSB3ZSdyZSBkZWFsaW5nXG4gICAgLy8gd2l0aCBmcm9tIHRoZSBkYXRhIGl0c2VsZi5cbiAgICB2YXIgc2VyaWFsaXplZFN0cmluZyA9IHZhbHVlLnN1YnN0cmluZyhUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCk7XG4gICAgdmFyIHR5cGUgPSB2YWx1ZS5zdWJzdHJpbmcoU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RILCBUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCk7XG5cbiAgICB2YXIgYmxvYlR5cGU7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGlibGUgYmxvYiB0eXBlIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kuXG4gICAgLy8gREJzIGNyZWF0ZWQgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBsb2NhbEZvcmFnZSB3aWxsIHNpbXBseSBub3QgaGF2ZSB0aGUgYmxvYiB0eXBlLlxuICAgIGlmICh0eXBlID09PSBUWVBFX0JMT0IgJiYgQkxPQl9UWVBFX1BSRUZJWF9SRUdFWC50ZXN0KHNlcmlhbGl6ZWRTdHJpbmcpKSB7XG4gICAgICAgIHZhciBtYXRjaGVyID0gc2VyaWFsaXplZFN0cmluZy5tYXRjaChCTE9CX1RZUEVfUFJFRklYX1JFR0VYKTtcbiAgICAgICAgYmxvYlR5cGUgPSBtYXRjaGVyWzFdO1xuICAgICAgICBzZXJpYWxpemVkU3RyaW5nID0gc2VyaWFsaXplZFN0cmluZy5zdWJzdHJpbmcobWF0Y2hlclswXS5sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoc2VyaWFsaXplZFN0cmluZyk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJpZ2h0IHR5cGUgYmFzZWQgb24gdGhlIGNvZGUvdHlwZSBzZXQgZHVyaW5nXG4gICAgLy8gc2VyaWFsaXphdGlvbi5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBUWVBFX0FSUkFZQlVGRkVSOlxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgY2FzZSBUWVBFX0JMT0I6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQmxvYihbYnVmZmVyXSwgeyB0eXBlOiBibG9iVHlwZSB9KTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDhBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UOEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UOENMQU1QRURBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDE2QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQxNkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfSU5UMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9GTE9BVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfRkxPQVQ2NEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59XG5cbnZhciBsb2NhbGZvcmFnZVNlcmlhbGl6ZXIgPSB7XG4gICAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIHN0cmluZ1RvQnVmZmVyOiBzdHJpbmdUb0J1ZmZlcixcbiAgICBidWZmZXJUb1N0cmluZzogYnVmZmVyVG9TdHJpbmdcbn07XG5cbi8qXG4gKiBJbmNsdWRlcyBjb2RlIGZyb206XG4gKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHQuZXhlY3V0ZVNxbCgnQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnICcgKyAnKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIGtleSB1bmlxdWUsIHZhbHVlKScsIFtdLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG59XG5cbi8vIE9wZW4gdGhlIFdlYlNRTCBkYXRhYmFzZSAoYXV0b21hdGljYWxseSBjcmVhdGVzIG9uZSBpZiBvbmUgZGlkbid0XG4vLyBwcmV2aW91c2x5IGV4aXN0KSwgdXNpbmcgYW55IG9wdGlvbnMgc2V0IGluIHRoZSBjb25maWcuXG5mdW5jdGlvbiBfaW5pdFN0b3JhZ2UkMShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7XG4gICAgICAgIGRiOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gdHlwZW9mIG9wdGlvbnNbaV0gIT09ICdzdHJpbmcnID8gb3B0aW9uc1tpXS50b1N0cmluZygpIDogb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYkluZm9Qcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIE9wZW4gdGhlIGRhdGFiYXNlOyB0aGUgb3BlbkRhdGFiYXNlIEFQSSB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gY3JlYXRlIGl0IGZvciB1cyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGJJbmZvLmRiID0gb3BlbkRhdGFiYXNlKGRiSW5mby5uYW1lLCBTdHJpbmcoZGJJbmZvLnZlcnNpb24pLCBkYkluZm8uZGVzY3JpcHRpb24sIGRiSW5mby5zaXplKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBvdXIga2V5L3ZhbHVlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZGJJbmZvLnNlcmlhbGl6ZXIgPSBsb2NhbGZvcmFnZVNlcmlhbGl6ZXI7XG4gICAgcmV0dXJuIGRiSW5mb1Byb21pc2U7XG59XG5cbmZ1bmN0aW9uIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCBzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdC5leGVjdXRlU3FsKHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gZXJyb3IuU1lOVEFYX0VSUikge1xuICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgJyArIFwiV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lID0gP1wiLCBbZGJJbmZvLnN0b3JlTmFtZV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YWJsZSBpcyBtaXNzaW5nICh3YXMgZGVsZXRlZClcbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtY3JlYXRlIGl0IHRhYmxlIGFuZCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5leGVjdXRlU3FsKHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKHQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sodCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgZXJyb3JDYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW0kMShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgKiBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBrZXkgPSA/IExJTUlUIDEnLCBba2V5XSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5sZW5ndGggPyByZXN1bHRzLnJvd3MuaXRlbSgwKS52YWx1ZSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgc2VyaWFsaXplZCBjb250ZW50IHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5wYWNrLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGUkMShpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuXG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCAqIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHJlc3VsdHMucm93cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcm93cy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHNlcmlhbGl6ZWQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB1bnBhY2suXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IocmVzdWx0LCBpdGVtLmtleSwgaSArIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2b2lkKDApIHByZXZlbnRzIHByb2JsZW1zIHdpdGggcmVkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBgdW5kZWZpbmVkYC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gX3NldEl0ZW0oa2V5LCB2YWx1ZSwgY2FsbGJhY2ssIHJldHJpZXNMZWZ0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUgbG9jYWxTdG9yYWdlIEFQSSBkb2Vzbid0IHJldHVybiB1bmRlZmluZWQgdmFsdWVzIGluIGFuXG4gICAgICAgICAgICAvLyBcImV4cGVjdGVkXCIgd2F5LCBzbyB1bmRlZmluZWQgaXMgYWx3YXlzIGNhc3QgdG8gbnVsbCBpbiBhbGxcbiAgICAgICAgICAgIC8vIGRyaXZlcnMuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5zZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyAnICsgJyhrZXksIHZhbHVlKSBWQUxVRVMgKD8sID8pJywgW2tleSwgdmFsdWVdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHJhbnNhY3Rpb24gZmFpbGVkOyBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2VlIGlmIGl0J3MgYSBxdW90YSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcWxFcnJvci5jb2RlID09PSBzcWxFcnJvci5RVU9UQV9FUlIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWplY3QgdGhlIGNhbGxiYWNrIG91dHJpZ2h0IGZvciBub3csIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgd29ydGggdHJ5aW5nIHRvIHJlLXJ1biB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdXNlciBhY2NlcHRzIHRoZSBwcm9tcHQgdG8gdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBzdG9yYWdlIG9uIFNhZmFyaSwgdGhpcyBlcnJvciB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlLXJ1biB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJpZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF9zZXRJdGVtLmFwcGx5KHNlbGYsIFtrZXksIG9yaWdpbmFsVmFsdWUsIGNhbGxiYWNrLCByZXRyaWVzTGVmdCAtIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHNldEl0ZW0kMShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfc2V0SXRlbS5hcHBseSh0aGlzLCBba2V5LCB2YWx1ZSwgY2FsbGJhY2ssIDFdKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSXRlbSQxKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0RFTEVURSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBrZXkgPSA/JywgW2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIERlbGV0ZXMgZXZlcnkgaXRlbSBpbiB0aGUgdGFibGUuXG4vLyBUT0RPOiBGaW5kIG91dCBpZiB0aGlzIHJlc2V0cyB0aGUgQVVUT19JTkNSRU1FTlQgbnVtYmVyLlxuZnVuY3Rpb24gY2xlYXIkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0RFTEVURSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gRG9lcyBhIHNpbXBsZSBgQ09VTlQoa2V5KWAgdG8gZ2V0IHRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluXG4vLyBsb2NhbEZvcmFnZS5cbmZ1bmN0aW9uIGxlbmd0aCQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIC8vIEFoaGgsIFNRTCBtYWtlcyB0aGlzIG9uZSBzb29vb29vIGVhc3kuXG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgQ09VTlQoa2V5KSBhcyBjIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLml0ZW0oMCkuYztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJldHVybiB0aGUga2V5IGxvY2F0ZWQgYXQga2V5IGluZGV4IFg7IGVzc2VudGlhbGx5IGdldHMgdGhlIGtleSBmcm9tIGFcbi8vIGBXSEVSRSBpZCA9ID9gLiBUaGlzIGlzIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgSSBjYW4gdGhpbmsgdG8gaW1wbGVtZW50XG4vLyB0aGlzIHJhcmVseS11c2VkIChpbiBteSBleHBlcmllbmNlKSBwYXJ0IG9mIHRoZSBBUEksIGJ1dCBpdCBjYW4gc2VlbVxuLy8gaW5jb25zaXN0ZW50LCBiZWNhdXNlIHdlIGRvIGBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPYCBvbiBgc2V0SXRlbSgpYCwgc29cbi8vIHRoZSBJRCBvZiBlYWNoIGtleSB3aWxsIGNoYW5nZSBldmVyeSB0aW1lIGl0J3MgdXBkYXRlZC4gUGVyaGFwcyBhIHN0b3JlZFxuLy8gcHJvY2VkdXJlIGZvciB0aGUgYHNldEl0ZW0oKWAgU1FMIHdvdWxkIHNvbHZlIHRoaXMgcHJvYmxlbT9cbi8vIFRPRE86IERvbid0IGNoYW5nZSBJRCBvbiBgc2V0SXRlbSgpYC5cbmZ1bmN0aW9uIGtleSQxKG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIGtleSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBpZCA9ID8gTElNSVQgMScsIFtuICsgMV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MubGVuZ3RoID8gcmVzdWx0cy5yb3dzLml0ZW0oMCkua2V5IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBrZXkgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChyZXN1bHRzLnJvd3MuaXRlbShpKS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZGF0YWJhc2UvI2RhdGFiYXNlc1xuLy8gPiBUaGVyZSBpcyBubyB3YXkgdG8gZW51bWVyYXRlIG9yIGRlbGV0ZSB0aGUgZGF0YWJhc2VzIGF2YWlsYWJsZSBmb3IgYW4gb3JpZ2luIGZyb20gdGhpcyBBUEkuXG5mdW5jdGlvbiBnZXRBbGxTdG9yZU5hbWVzKGRiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgJyArIFwiV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lIDw+ICdfX1dlYktpdERhdGFiYXNlSW5mb1RhYmxlX18nXCIsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLnB1c2gocmVzdWx0cy5yb3dzLml0ZW0oaSkubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRiOiBkYixcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lczogc3RvcmVOYW1lc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2UkMShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBjdXJyZW50Q29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgY3VycmVudENvbmZpZy5uYW1lO1xuICAgICAgICBvcHRpb25zLnN0b3JlTmFtZSA9IG9wdGlvbnMuc3RvcmVOYW1lIHx8IGN1cnJlbnRDb25maWcuc3RvcmVOYW1lO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdCgnSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIGRiO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBkYiByZWZlcmVuY2Ugb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBkYiA9IHNlbGYuX2RiSW5mby5kYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGIgPSBvcGVuRGF0YWJhc2Uob3B0aW9ucy5uYW1lLCAnJywgJycsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcCBhbGwgZGF0YWJhc2UgdGFibGVzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShnZXRBbGxTdG9yZU5hbWVzKGRiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBkYjogZGIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXM6IFtvcHRpb25zLnN0b3JlTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAob3BlcmF0aW9uSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJvcFRhYmxlKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnRFJPUCBUQUJMRSBJRiBFWElTVFMgJyArIHN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb3BlcmF0aW9uSW5mby5zdG9yZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goZHJvcFRhYmxlKG9wZXJhdGlvbkluZm8uc3RvcmVOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSQxLmFsbChvcGVyYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgd2ViU1FMU3RvcmFnZSA9IHtcbiAgICBfZHJpdmVyOiAnd2ViU1FMU3RvcmFnZScsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UkMSxcbiAgICBfc3VwcG9ydDogaXNXZWJTUUxWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUkMSxcbiAgICBnZXRJdGVtOiBnZXRJdGVtJDEsXG4gICAgc2V0SXRlbTogc2V0SXRlbSQxLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0kMSxcbiAgICBjbGVhcjogY2xlYXIkMSxcbiAgICBsZW5ndGg6IGxlbmd0aCQxLFxuICAgIGtleToga2V5JDEsXG4gICAga2V5czoga2V5cyQxLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlJDFcbn07XG5cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmICdzZXRJdGVtJyBpbiBsb2NhbFN0b3JhZ2UgJiZcbiAgICAgICAgLy8gaW4gSUU4IHR5cGVvZiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSA9PT0gJ29iamVjdCdcbiAgICAgICAgISFsb2NhbFN0b3JhZ2Uuc2V0SXRlbTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlQcmVmaXgob3B0aW9ucywgZGVmYXVsdENvbmZpZykge1xuICAgIHZhciBrZXlQcmVmaXggPSBvcHRpb25zLm5hbWUgKyAnLyc7XG5cbiAgICBpZiAob3B0aW9ucy5zdG9yZU5hbWUgIT09IGRlZmF1bHRDb25maWcuc3RvcmVOYW1lKSB7XG4gICAgICAgIGtleVByZWZpeCArPSBvcHRpb25zLnN0b3JlTmFtZSArICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGtleVByZWZpeDtcbn1cblxuLy8gQ2hlY2sgaWYgbG9jYWxTdG9yYWdlIHRocm93cyB3aGVuIHNhdmluZyBhbiBpdGVtXG5mdW5jdGlvbiBjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzKCkge1xuICAgIHZhciBsb2NhbFN0b3JhZ2VUZXN0S2V5ID0gJ19sb2NhbGZvcmFnZV9zdXBwb3J0X3Rlc3QnO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdG9yYWdlVGVzdEtleSwgdHJ1ZSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGxvY2FsU3RvcmFnZVRlc3RLZXkpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLy8gQ2hlY2sgaWYgbG9jYWxTdG9yYWdlIGlzIHVzYWJsZSBhbmQgYWxsb3dzIHRvIHNhdmUgYW4gaXRlbVxuLy8gVGhpcyBtZXRob2QgY2hlY2tzIGlmIGxvY2FsU3RvcmFnZSBpcyB1c2FibGUgaW4gU2FmYXJpIFByaXZhdGUgQnJvd3Npbmdcbi8vIG1vZGUsIG9yIGluIGFueSBvdGhlciBjYXNlIHdoZXJlIHRoZSBhdmFpbGFibGUgcXVvdGEgZm9yIGxvY2FsU3RvcmFnZVxuLy8gaXMgMCBhbmQgdGhlcmUgd2Fzbid0IGFueSBzYXZlZCBpdGVtcyB5ZXQuXG5mdW5jdGlvbiBfaXNMb2NhbFN0b3JhZ2VVc2FibGUoKSB7XG4gICAgcmV0dXJuICFjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzKCkgfHwgbG9jYWxTdG9yYWdlLmxlbmd0aCA+IDA7XG59XG5cbi8vIENvbmZpZyB0aGUgbG9jYWxTdG9yYWdlIGJhY2tlbmQsIHVzaW5nIG9wdGlvbnMgc2V0IGluIHRoZSBjb25maWcuXG5mdW5jdGlvbiBfaW5pdFN0b3JhZ2UkMihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7fTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRiSW5mb1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYkluZm8ua2V5UHJlZml4ID0gX2dldEtleVByZWZpeChvcHRpb25zLCBzZWxmLl9kZWZhdWx0Q29uZmlnKTtcblxuICAgIGlmICghX2lzTG9jYWxTdG9yYWdlVXNhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZWplY3QoKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgZGJJbmZvLnNlcmlhbGl6ZXIgPSBsb2NhbGZvcmFnZVNlcmlhbGl6ZXI7XG5cbiAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbn1cblxuLy8gUmVtb3ZlIGFsbCBrZXlzIGZyb20gdGhlIGRhdGFzdG9yZSwgZWZmZWN0aXZlbHkgZGVzdHJveWluZyBhbGwgZGF0YSBpblxuLy8gdGhlIGFwcCdzIGtleS92YWx1ZSBzdG9yZSFcbmZ1bmN0aW9uIGNsZWFyJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBzZWxmLl9kYkluZm8ua2V5UHJlZml4O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJldHJpZXZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RvcmUuIFVubGlrZSB0aGUgb3JpZ2luYWwgYXN5bmNfc3RvcmFnZVxuLy8gbGlicmFyeSBpbiBHYWlhLCB3ZSBkb24ndCBtb2RpZnkgcmV0dXJuIHZhbHVlcyBhdCBhbGwuIElmIGEga2V5J3MgdmFsdWVcbi8vIGlzIGB1bmRlZmluZWRgLCB3ZSBwYXNzIHRoYXQgdmFsdWUgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuZnVuY3Rpb24gZ2V0SXRlbSQyKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSk7XG5cbiAgICAgICAgLy8gSWYgYSByZXN1bHQgd2FzIGZvdW5kLCBwYXJzZSBpdCBmcm9tIHRoZSBzZXJpYWxpemVkXG4gICAgICAgIC8vIHN0cmluZyBpbnRvIGEgSlMgb2JqZWN0LiBJZiByZXN1bHQgaXNuJ3QgdHJ1dGh5LCB0aGUga2V5XG4gICAgICAgIC8vIGlzIGxpa2VseSB1bmRlZmluZWQgYW5kIHdlJ2xsIHBhc3MgaXQgc3RyYWlnaHQgdG8gdGhlXG4gICAgICAgIC8vIGNhbGxiYWNrLlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIEl0ZXJhdGUgb3ZlciBhbGwgaXRlbXMgaW4gdGhlIHN0b3JlLlxuZnVuY3Rpb24gaXRlcmF0ZSQyKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIga2V5UHJlZml4ID0gZGJJbmZvLmtleVByZWZpeDtcbiAgICAgICAgdmFyIGtleVByZWZpeExlbmd0aCA9IGtleVByZWZpeC5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBsb2NhbFN0b3JhZ2UubGVuZ3RoO1xuXG4gICAgICAgIC8vIFdlIHVzZSBhIGRlZGljYXRlZCBpdGVyYXRvciBpbnN0ZWFkIG9mIHRoZSBgaWAgdmFyaWFibGUgYmVsb3dcbiAgICAgICAgLy8gc28gb3RoZXIga2V5cyB3ZSBmZXRjaCBpbiBsb2NhbFN0b3JhZ2UgYXJlbid0IGNvdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIGBpdGVyYXRpb25OdW1iZXJgIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgYGl0ZXJhdGUoKWBcbiAgICAgICAgLy8gY2FsbGJhY2suXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTogZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDM1I2Rpc2N1c3Npb25fcjM4MDYxNTMwXG4gICAgICAgIHZhciBpdGVyYXRpb25OdW1iZXIgPSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGEgcmVzdWx0IHdhcyBmb3VuZCwgcGFyc2UgaXQgZnJvbSB0aGUgc2VyaWFsaXplZFxuICAgICAgICAgICAgLy8gc3RyaW5nIGludG8gYSBKUyBvYmplY3QuIElmIHJlc3VsdCBpc24ndCB0cnV0aHksIHRoZVxuICAgICAgICAgICAgLy8ga2V5IGlzIGxpa2VseSB1bmRlZmluZWQgYW5kIHdlJ2xsIHBhc3MgaXQgc3RyYWlnaHRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZXJhdG9yKHZhbHVlLCBrZXkuc3Vic3RyaW5nKGtleVByZWZpeExlbmd0aCksIGl0ZXJhdGlvbk51bWJlcisrKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFNhbWUgYXMgbG9jYWxTdG9yYWdlJ3Mga2V5KCkgbWV0aG9kLCBleGNlcHQgdGFrZXMgYSBjYWxsYmFjay5cbmZ1bmN0aW9uIGtleSQyKG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxTdG9yYWdlLmtleShuKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHByZWZpeCBmcm9tIHRoZSBrZXksIGlmIGEga2V5IGlzIGZvdW5kLlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKGRiSW5mby5rZXlQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBrZXlzJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciBsZW5ndGggPSBsb2NhbFN0b3JhZ2UubGVuZ3RoO1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgIGlmIChpdGVtS2V5LmluZGV4T2YoZGJJbmZvLmtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goaXRlbUtleS5zdWJzdHJpbmcoZGJJbmZvLmtleVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU3VwcGx5IHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgZGF0YXN0b3JlIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbmZ1bmN0aW9uIGxlbmd0aCQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBzdG9yZSwgbmljZSBhbmQgc2ltcGxlLlxuZnVuY3Rpb24gcmVtb3ZlSXRlbSQyKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFNldCBhIGtleSdzIHZhbHVlIGFuZCBydW4gYW4gb3B0aW9uYWwgY2FsbGJhY2sgb25jZSB0aGUgdmFsdWUgaXMgc2V0LlxuLy8gVW5saWtlIEdhaWEncyBpbXBsZW1lbnRhdGlvbiwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgdmFsdWUsXG4vLyBpbiBjYXNlIHlvdSB3YW50IHRvIG9wZXJhdGUgb24gdGhhdCB2YWx1ZSBvbmx5IGFmdGVyIHlvdSdyZSBzdXJlIGl0XG4vLyBzYXZlZCwgb3Igc29tZXRoaW5nIGxpa2UgdGhhdC5cbmZ1bmN0aW9uIHNldEl0ZW0kMihrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdW5kZWZpbmVkIHZhbHVlcyB0byBudWxsLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYXBhY2l0eSBleGNlZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBhIHNwZWNpZmljIGVycm9yL2V2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHwgZS5uYW1lID09PSAnTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlJDIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvcHRpb25zLm5hbWUgKyAnLycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF9nZXRLZXlQcmVmaXgob3B0aW9ucywgc2VsZi5fZGVmYXVsdENvbmZpZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChrZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgbG9jYWxTdG9yYWdlV3JhcHBlciA9IHtcbiAgICBfZHJpdmVyOiAnbG9jYWxTdG9yYWdlV3JhcHBlcicsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UkMixcbiAgICBfc3VwcG9ydDogaXNMb2NhbFN0b3JhZ2VWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUkMixcbiAgICBnZXRJdGVtOiBnZXRJdGVtJDIsXG4gICAgc2V0SXRlbTogc2V0SXRlbSQyLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0kMixcbiAgICBjbGVhcjogY2xlYXIkMixcbiAgICBsZW5ndGg6IGxlbmd0aCQyLFxuICAgIGtleToga2V5JDIsXG4gICAga2V5czoga2V5cyQyLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlJDJcbn07XG5cbnZhciBzYW1lVmFsdWUgPSBmdW5jdGlvbiBzYW1lVmFsdWUoeCwgeSkge1xuICAgIHJldHVybiB4ID09PSB5IHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PT0gJ251bWJlcicgJiYgaXNOYU4oeCkgJiYgaXNOYU4oeSk7XG59O1xuXG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgc2VhcmNoRWxlbWVudCkge1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChzYW1lVmFsdWUoYXJyYXlbaV0sIHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBEcml2ZXJzIGFyZSBzdG9yZWQgaGVyZSB3aGVuIGBkZWZpbmVEcml2ZXIoKWAgaXMgY2FsbGVkLlxuLy8gVGhleSBhcmUgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIGxvY2FsRm9yYWdlLlxudmFyIERlZmluZWREcml2ZXJzID0ge307XG5cbnZhciBEcml2ZXJTdXBwb3J0ID0ge307XG5cbnZhciBEZWZhdWx0RHJpdmVycyA9IHtcbiAgICBJTkRFWEVEREI6IGFzeW5jU3RvcmFnZSxcbiAgICBXRUJTUUw6IHdlYlNRTFN0b3JhZ2UsXG4gICAgTE9DQUxTVE9SQUdFOiBsb2NhbFN0b3JhZ2VXcmFwcGVyXG59O1xuXG52YXIgRGVmYXVsdERyaXZlck9yZGVyID0gW0RlZmF1bHREcml2ZXJzLklOREVYRUREQi5fZHJpdmVyLCBEZWZhdWx0RHJpdmVycy5XRUJTUUwuX2RyaXZlciwgRGVmYXVsdERyaXZlcnMuTE9DQUxTVE9SQUdFLl9kcml2ZXJdO1xuXG52YXIgT3B0aW9uYWxEcml2ZXJNZXRob2RzID0gWydkcm9wSW5zdGFuY2UnXTtcblxudmFyIExpYnJhcnlNZXRob2RzID0gWydjbGVhcicsICdnZXRJdGVtJywgJ2l0ZXJhdGUnLCAna2V5JywgJ2tleXMnLCAnbGVuZ3RoJywgJ3JlbW92ZUl0ZW0nLCAnc2V0SXRlbSddLmNvbmNhdChPcHRpb25hbERyaXZlck1ldGhvZHMpO1xuXG52YXIgRGVmYXVsdENvbmZpZyA9IHtcbiAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgZHJpdmVyOiBEZWZhdWx0RHJpdmVyT3JkZXIuc2xpY2UoKSxcbiAgICBuYW1lOiAnbG9jYWxmb3JhZ2UnLFxuICAgIC8vIERlZmF1bHQgREIgc2l6ZSBpcyBfSlVTVCBVTkRFUl8gNU1CLCBhcyBpdCdzIHRoZSBoaWdoZXN0IHNpemVcbiAgICAvLyB3ZSBjYW4gdXNlIHdpdGhvdXQgYSBwcm9tcHQuXG4gICAgc2l6ZTogNDk4MDczNixcbiAgICBzdG9yZU5hbWU6ICdrZXl2YWx1ZXBhaXJzJyxcbiAgICB2ZXJzaW9uOiAxLjBcbn07XG5cbmZ1bmN0aW9uIGNhbGxXaGVuUmVhZHkobG9jYWxGb3JhZ2VJbnN0YW5jZSwgbGlicmFyeU1ldGhvZCkge1xuICAgIGxvY2FsRm9yYWdlSW5zdGFuY2VbbGlicmFyeU1ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGxvY2FsRm9yYWdlSW5zdGFuY2UucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZvcmFnZUluc3RhbmNlW2xpYnJhcnlNZXRob2RdLmFwcGx5KGxvY2FsRm9yYWdlSW5zdGFuY2UsIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ1tfa2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXVtfa2V5XSA9IGFyZ1tfa2V5XS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdW19rZXldID0gYXJnW19rZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbn1cblxudmFyIExvY2FsRm9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsRm9yYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2FsRm9yYWdlKTtcblxuICAgICAgICBmb3IgKHZhciBkcml2ZXJUeXBlS2V5IGluIERlZmF1bHREcml2ZXJzKSB7XG4gICAgICAgICAgICBpZiAoRGVmYXVsdERyaXZlcnMuaGFzT3duUHJvcGVydHkoZHJpdmVyVHlwZUtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyID0gRGVmYXVsdERyaXZlcnNbZHJpdmVyVHlwZUtleV07XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXIuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICB0aGlzW2RyaXZlclR5cGVLZXldID0gZHJpdmVyTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgZHJpdmVycyBjYW4gYmUgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIGJsb2NraW5nIG1hbm5lclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZURyaXZlcihkcml2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlZmF1bHRDb25maWcgPSBleHRlbmQoe30sIERlZmF1bHRDb25maWcpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBleHRlbmQoe30sIHRoaXMuX2RlZmF1bHRDb25maWcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kcml2ZXJTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbml0RHJpdmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGJJbmZvID0gbnVsbDtcblxuICAgICAgICB0aGlzLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKTtcbiAgICAgICAgdGhpcy5zZXREcml2ZXIodGhpcy5fY29uZmlnLmRyaXZlcilbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFueSBjb25maWcgdmFsdWVzIGZvciBsb2NhbEZvcmFnZTsgY2FuIGJlIGNhbGxlZCBhbnl0aW1lIGJlZm9yZVxuICAgIC8vIHRoZSBmaXJzdCBBUEkgY2FsbCAoZS5nLiBgZ2V0SXRlbWAsIGBzZXRJdGVtYCkuXG4gICAgLy8gV2UgbG9vcCB0aHJvdWdoIG9wdGlvbnMgc28gd2UgZG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGNvbmZpZ1xuICAgIC8vIHZhbHVlcy5cblxuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uIGNvbmZpZyhvcHRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSBvcHRpb25zIGFyZ3VtZW50IGlzIGFuIG9iamVjdCwgd2UgdXNlIGl0IHRvIHNldCB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgcmV0dXJuIGVpdGhlciBhIHNwZWNpZmllZCBjb25maWcgdmFsdWUgb3IgYWxsXG4gICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMuXG4gICAgICAgIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIElmIGxvY2FsZm9yYWdlIGlzIHJlYWR5IGFuZCBmdWxseSBpbml0aWFsaXplZCwgd2UgY2FuJ3Qgc2V0XG4gICAgICAgICAgICAvLyBhbnkgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzLiBJbnN0ZWFkLCB3ZSByZXR1cm4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQ2FuJ3QgY2FsbCBjb25maWcoKSBhZnRlciBsb2NhbGZvcmFnZSBcIiArICdoYXMgYmVlbiB1c2VkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJ3N0b3JlTmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IG9wdGlvbnNbaV0ucmVwbGFjZSgvXFxXL2csICdfJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICd2ZXJzaW9uJyAmJiB0eXBlb2Ygb3B0aW9uc1tpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignRGF0YWJhc2UgdmVyc2lvbiBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbmZpZ1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFmdGVyIGFsbCBjb25maWcgb3B0aW9ucyBhcmUgc2V0IGFuZFxuICAgICAgICAgICAgLy8gdGhlIGRyaXZlciBvcHRpb24gaXMgdXNlZCwgdHJ5IHNldHRpbmcgaXRcbiAgICAgICAgICAgIGlmICgnZHJpdmVyJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWdbb3B0aW9uc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVzZWQgdG8gZGVmaW5lIGEgY3VzdG9tIGRyaXZlciwgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mXG4gICAgLy8gbG9jYWxGb3JhZ2UuXG5cblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5kZWZpbmVEcml2ZXIgPSBmdW5jdGlvbiBkZWZpbmVEcml2ZXIoZHJpdmVyT2JqZWN0LCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlck9iamVjdC5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGlhbmNlRXJyb3IgPSBuZXcgRXJyb3IoJ0N1c3RvbSBkcml2ZXIgbm90IGNvbXBsaWFudDsgc2VlICcgKyAnaHR0cHM6Ly9tb3ppbGxhLmdpdGh1Yi5pby9sb2NhbEZvcmFnZS8jZGVmaW5lZHJpdmVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBIGRyaXZlciBuYW1lIHNob3VsZCBiZSBkZWZpbmVkIGFuZCBub3Qgb3ZlcmxhcCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxpYnJhcnktZGVmaW5lZCwgZGVmYXVsdCBkcml2ZXJzLlxuICAgICAgICAgICAgICAgIGlmICghZHJpdmVyT2JqZWN0Ll9kcml2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNvbXBsaWFuY2VFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTWV0aG9kcyA9IExpYnJhcnlNZXRob2RzLmNvbmNhdCgnX2luaXRTdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRyaXZlck1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyaXZlck1ldGhvZE5hbWUgPSBkcml2ZXJNZXRob2RzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHByb3BlcnR5IGlzIHRoZXJlLFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgYSBtZXRob2QgZXZlbiB3aGVuIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gIWluY2x1ZGVzKE9wdGlvbmFsRHJpdmVyTWV0aG9kcywgZHJpdmVyTWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXNSZXF1aXJlZCB8fCBkcml2ZXJPYmplY3RbZHJpdmVyTWV0aG9kTmFtZV0pICYmIHR5cGVvZiBkcml2ZXJPYmplY3RbZHJpdmVyTWV0aG9kTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChjb21wbGlhbmNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzID0gZnVuY3Rpb24gY29uZmlndXJlTWlzc2luZ01ldGhvZHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3RvcnkgPSBmdW5jdGlvbiBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3RvcnkobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kTmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBjdXJyZW50IGRyaXZlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBPcHRpb25hbERyaXZlck1ldGhvZHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25hbERyaXZlck1ldGhvZCA9IE9wdGlvbmFsRHJpdmVyTWV0aG9kc1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRyaXZlck9iamVjdFtvcHRpb25hbERyaXZlck1ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcml2ZXJPYmplY3Rbb3B0aW9uYWxEcml2ZXJNZXRob2RdID0gbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5KG9wdGlvbmFsRHJpdmVyTWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25maWd1cmVNaXNzaW5nTWV0aG9kcygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldERyaXZlclN1cHBvcnQgPSBmdW5jdGlvbiBzZXREcml2ZXJTdXBwb3J0KHN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1JlZGVmaW5pbmcgTG9jYWxGb3JhZ2UgZHJpdmVyOiAnICsgZHJpdmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0gPSBkcml2ZXJPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIERyaXZlclN1cHBvcnRbZHJpdmVyTmFtZV0gPSBzdXBwb3J0O1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgYSB0aGVuLCBzbyB0aGF0IHdlIGNhbiBkZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJpdmVycyB0aGF0IGhhdmUgc2ltcGxlIF9zdXBwb3J0IG1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSBibG9ja2luZyBtYW5uZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoJ19zdXBwb3J0JyBpbiBkcml2ZXJPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyaXZlck9iamVjdC5fc3VwcG9ydCAmJiB0eXBlb2YgZHJpdmVyT2JqZWN0Ll9zdXBwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcml2ZXJPYmplY3QuX3N1cHBvcnQoKS50aGVuKHNldERyaXZlclN1cHBvcnQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJTdXBwb3J0KCEhZHJpdmVyT2JqZWN0Ll9zdXBwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyaXZlclN1cHBvcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZHJpdmVyID0gZnVuY3Rpb24gZHJpdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyIHx8IG51bGw7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5nZXREcml2ZXIgPSBmdW5jdGlvbiBnZXREcml2ZXIoZHJpdmVyTmFtZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGdldERyaXZlclByb21pc2UgPSBEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSA/IFByb21pc2UkMS5yZXNvbHZlKERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSA6IFByb21pc2UkMS5yZWplY3QobmV3IEVycm9yKCdEcml2ZXIgbm90IGZvdW5kLicpKTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKGdldERyaXZlclByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGdldERyaXZlclByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5nZXRTZXJpYWxpemVyID0gZnVuY3Rpb24gZ2V0U2VyaWFsaXplcihjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VyaWFsaXplclByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZShsb2NhbGZvcmFnZVNlcmlhbGl6ZXIpO1xuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHNlcmlhbGl6ZXJQcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyUHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5fZHJpdmVyU2V0LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3JlYWR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBzZWxmLl9pbml0RHJpdmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWFkeTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlcihkcml2ZXJzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGRyaXZlcnMpKSB7XG4gICAgICAgICAgICBkcml2ZXJzID0gW2RyaXZlcnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1cHBvcnRlZERyaXZlcnMgPSB0aGlzLl9nZXRTdXBwb3J0ZWREcml2ZXJzKGRyaXZlcnMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldERyaXZlclRvQ29uZmlnKCkge1xuICAgICAgICAgICAgc2VsZi5fY29uZmlnLmRyaXZlciA9IHNlbGYuZHJpdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHRlbmRTZWxmV2l0aERyaXZlcihkcml2ZXIpIHtcbiAgICAgICAgICAgIHNlbGYuX2V4dGVuZChkcml2ZXIpO1xuICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcblxuICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBzZWxmLl9pbml0U3RvcmFnZShzZWxmLl9jb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlYWR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdERyaXZlcihzdXBwb3J0ZWREcml2ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RHJpdmVySW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJpdmVyUHJvbWlzZUxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50RHJpdmVySW5kZXggPCBzdXBwb3J0ZWREcml2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBzdXBwb3J0ZWREcml2ZXJzW2N1cnJlbnREcml2ZXJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHJpdmVySW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RHJpdmVyKGRyaXZlck5hbWUpLnRoZW4oZXh0ZW5kU2VsZldpdGhEcml2ZXIpW1wiY2F0Y2hcIl0oZHJpdmVyUHJvbWlzZUxvb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RyaXZlclNldCA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZHJpdmVyU2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkcml2ZXJQcm9taXNlTG9vcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIGEgZHJpdmVyIGluaXRpYWxpemF0aW9uIGluIHByb2dyZXNzXG4gICAgICAgIC8vIHNvIHdhaXQgZm9yIGl0IHRvIGZpbmlzaCBpbiBvcmRlciB0byBhdm9pZCBhIHBvc3NpYmxlXG4gICAgICAgIC8vIHJhY2UgY29uZGl0aW9uIHRvIHNldCBfZGJJbmZvXG4gICAgICAgIHZhciBvbGREcml2ZXJTZXREb25lID0gdGhpcy5fZHJpdmVyU2V0ICE9PSBudWxsID8gdGhpcy5fZHJpdmVyU2V0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gICAgICAgIH0pIDogUHJvbWlzZSQxLnJlc29sdmUoKTtcblxuICAgICAgICB0aGlzLl9kcml2ZXJTZXQgPSBvbGREcml2ZXJTZXREb25lLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBzdXBwb3J0ZWREcml2ZXJzWzBdO1xuICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RHJpdmVyKGRyaXZlck5hbWUpLnRoZW4oZnVuY3Rpb24gKGRyaXZlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RyaXZlciA9IGRyaXZlci5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5pdERyaXZlciA9IGluaXREcml2ZXIoc3VwcG9ydGVkRHJpdmVycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuJyk7XG4gICAgICAgICAgICBzZWxmLl9kcml2ZXJTZXQgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9kcml2ZXJTZXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3ModGhpcy5fZHJpdmVyU2V0LCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcml2ZXJTZXQ7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIHN1cHBvcnRzKGRyaXZlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhRHJpdmVyU3VwcG9ydFtkcml2ZXJOYW1lXTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl9leHRlbmQgPSBmdW5jdGlvbiBfZXh0ZW5kKGxpYnJhcnlNZXRob2RzQW5kUHJvcGVydGllcykge1xuICAgICAgICBleHRlbmQodGhpcywgbGlicmFyeU1ldGhvZHNBbmRQcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl9nZXRTdXBwb3J0ZWREcml2ZXJzID0gZnVuY3Rpb24gX2dldFN1cHBvcnRlZERyaXZlcnMoZHJpdmVycykge1xuICAgICAgICB2YXIgc3VwcG9ydGVkRHJpdmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZHJpdmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHMoZHJpdmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWREcml2ZXJzLnB1c2goZHJpdmVyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZERyaXZlcnM7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5ID0gZnVuY3Rpb24gX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpIHtcbiAgICAgICAgLy8gQWRkIGEgc3R1YiBmb3IgZWFjaCBkcml2ZXIgQVBJIG1ldGhvZCB0aGF0IGRlbGF5cyB0aGUgY2FsbCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkcml2ZXIgbWV0aG9kIHVudGlsIGxvY2FsRm9yYWdlIGlzIHJlYWR5LiBUaGVzZSBzdHVic1xuICAgICAgICAvLyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBkcml2ZXIgbWV0aG9kcyBhcyBzb29uIGFzIHRoZSBkcml2ZXIgaXNcbiAgICAgICAgLy8gbG9hZGVkLCBzbyB0aGVyZSBpcyBubyBwZXJmb3JtYW5jZSBpbXBhY3QuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBMaWJyYXJ5TWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2FsbFdoZW5SZWFkeSh0aGlzLCBMaWJyYXJ5TWV0aG9kc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IExvY2FsRm9yYWdlKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTG9jYWxGb3JhZ2U7XG59KCk7XG5cbi8vIFRoZSBhY3R1YWwgbG9jYWxGb3JhZ2Ugb2JqZWN0IHRoYXQgd2UgZXhwb3NlIGFzIGEgbW9kdWxlIG9yIHZpYSBhXG4vLyBnbG9iYWwuIEl0J3MgZXh0ZW5kZWQgYnkgcHVsbGluZyBpbiBvbmUgb2Ygb3VyIG90aGVyIGxpYnJhcmllcy5cblxuXG52YXIgbG9jYWxmb3JhZ2VfanMgPSBuZXcgTG9jYWxGb3JhZ2UoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhbGZvcmFnZV9qcztcblxufSx7XCIzXCI6M31dfSx7fSxbNF0pKDQpXG59KTtcbiJdLCJuYW1lcyI6WyJmIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImciLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwibG9jYWxmb3JhZ2UiLCJlIiwidCIsIm4iLCJyIiwicyIsIm8iLCJ1IiwiYSIsInJlcXVpcmUiLCJpIiwiRXJyb3IiLCJjb2RlIiwibCIsImNhbGwiLCJsZW5ndGgiLCJfZGVyZXFfIiwiTXV0YXRpb24iLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsInNjaGVkdWxlRHJhaW4iLCJjYWxsZWQiLCJvYnNlcnZlciIsIm5leHRUaWNrIiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsImRhdGEiLCJzZXRJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJjcmVhdGVFbGVtZW50Iiwic2NyaXB0RWwiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInNldFRpbWVvdXQiLCJkcmFpbmluZyIsInF1ZXVlIiwib2xkUXVldWUiLCJsZW4iLCJpbW1lZGlhdGUiLCJ0YXNrIiwicHVzaCIsIklOVEVSTkFMIiwiaGFuZGxlcnMiLCJSRUpFQ1RFRCIsIkZVTEZJTExFRCIsIlBFTkRJTkciLCJQcm9taXNlIiwicmVzb2x2ZXIiLCJUeXBlRXJyb3IiLCJzdGF0ZSIsIm91dGNvbWUiLCJzYWZlbHlSZXNvbHZlVGhlbmFibGUiLCJwcm90b3R5cGUiLCJvblJlamVjdGVkIiwidGhlbiIsIm9uRnVsZmlsbGVkIiwicHJvbWlzZSIsImNvbnN0cnVjdG9yIiwidW53cmFwIiwiUXVldWVJdGVtIiwiY2FsbEZ1bGZpbGxlZCIsIm90aGVyQ2FsbEZ1bGZpbGxlZCIsImNhbGxSZWplY3RlZCIsIm90aGVyQ2FsbFJlamVjdGVkIiwidmFsdWUiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVuYyIsInJldHVyblZhbHVlIiwicmVzdWx0IiwidHJ5Q2F0Y2giLCJnZXRUaGVuIiwic3RhdHVzIiwidGhlbmFibGUiLCJlcnJvciIsIm9iaiIsImFwcHlUaGVuIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJvbkVycm9yIiwib25TdWNjZXNzIiwidHJ5VG9VbndyYXAiLCJvdXQiLCJyZWFzb24iLCJhbGwiLCJpdGVyYWJsZSIsIk9iamVjdCIsInRvU3RyaW5nIiwidmFsdWVzIiwiQXJyYXkiLCJyZXNvbHZlZCIsImFsbFJlc29sdmVyIiwicmVzb2x2ZUZyb21BbGwiLCJvdXRWYWx1ZSIsInJhY2UiLCJyZXNwb25zZSIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJnZXRJREIiLCJpbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtb3pJbmRleGVkREIiLCJPSW5kZXhlZERCIiwibXNJbmRleGVkREIiLCJpZGIiLCJpc0luZGV4ZWREQlZhbGlkIiwib3BlbiIsImlzU2FmYXJpIiwib3BlbkRhdGFiYXNlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInBsYXRmb3JtIiwiaGFzRmV0Y2giLCJmZXRjaCIsImluZGV4T2YiLCJJREJLZXlSYW5nZSIsImNyZWF0ZUJsb2IiLCJwYXJ0cyIsInByb3BlcnRpZXMiLCJCbG9iIiwibmFtZSIsIkJ1aWxkZXIiLCJCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiYnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJ0eXBlIiwiUHJvbWlzZSQxIiwiZXhlY3V0ZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJleGVjdXRlVHdvQ2FsbGJhY2tzIiwiZXJyb3JDYWxsYmFjayIsIm5vcm1hbGl6ZUtleSIsImtleSIsImNvbnNvbGUiLCJ3YXJuIiwiU3RyaW5nIiwiZ2V0Q2FsbGJhY2siLCJERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFIiwic3VwcG9ydHNCbG9icyIsImRiQ29udGV4dHMiLCJSRUFEX09OTFkiLCJSRUFEX1dSSVRFIiwiX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIiLCJiaW4iLCJidWYiLCJBcnJheUJ1ZmZlciIsImFyciIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiX2NoZWNrQmxvYlN1cHBvcnRXaXRob3V0Q2FjaGluZyIsInR4biIsInRyYW5zYWN0aW9uIiwiYmxvYiIsIm9iamVjdFN0b3JlIiwicHV0Iiwib25hYm9ydCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwib25jb21wbGV0ZSIsIm1hdGNoZWRDaHJvbWUiLCJtYXRjaCIsIm1hdGNoZWRFZGdlIiwicGFyc2VJbnQiLCJfY2hlY2tCbG9iU3VwcG9ydCIsIl9kZWZlclJlYWRpbmVzcyIsImRiSW5mbyIsImRiQ29udGV4dCIsImRlZmVycmVkT3BlcmF0aW9uIiwiZGVmZXJyZWRPcGVyYXRpb25zIiwiZGJSZWFkeSIsIl9hZHZhbmNlUmVhZGluZXNzIiwicG9wIiwiX3JlamVjdFJlYWRpbmVzcyIsImVyciIsIl9nZXRDb25uZWN0aW9uIiwidXBncmFkZU5lZWRlZCIsImNyZWF0ZURiQ29udGV4dCIsImRiIiwiY2xvc2UiLCJkYkFyZ3MiLCJ2ZXJzaW9uIiwib3BlbnJlcSIsIm9udXBncmFkZW5lZWRlZCIsImNyZWF0ZU9iamVjdFN0b3JlIiwic3RvcmVOYW1lIiwib2xkVmVyc2lvbiIsImV4IiwibmV3VmVyc2lvbiIsIm9uZXJyb3IiLCJvbnN1Y2Nlc3MiLCJvbnZlcnNpb25jaGFuZ2UiLCJ0YXJnZXQiLCJfZ2V0T3JpZ2luYWxDb25uZWN0aW9uIiwiX2dldFVwZ3JhZGVkQ29ubmVjdGlvbiIsIl9pc1VwZ3JhZGVOZWVkZWQiLCJkZWZhdWx0VmVyc2lvbiIsImlzTmV3U3RvcmUiLCJvYmplY3RTdG9yZU5hbWVzIiwiY29udGFpbnMiLCJpc0Rvd25ncmFkZSIsImlzVXBncmFkZSIsImluY1ZlcnNpb24iLCJfZW5jb2RlQmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWRlbmQiLCJiYXNlNjQiLCJidG9hIiwiX19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iIiwicmVhZEFzQmluYXJ5U3RyaW5nIiwiX2RlY29kZUJsb2IiLCJlbmNvZGVkQmxvYiIsImFycmF5QnVmZiIsImF0b2IiLCJfaXNFbmNvZGVkQmxvYiIsIl9mdWxseVJlYWR5IiwiX2luaXRSZWFkeSIsIl9kYkluZm8iLCJfdHJ5UmVjb25uZWN0IiwiZm9yYWdlcyIsImZvcmFnZSIsImNyZWF0ZVRyYW5zYWN0aW9uIiwibW9kZSIsInJldHJpZXMiLCJ1bmRlZmluZWQiLCJ0eCIsIl9pbml0U3RvcmFnZSIsIm9wdGlvbnMiLCJyZWFkeSIsImluaXRQcm9taXNlcyIsImlnbm9yZUVycm9ycyIsImoiLCJzbGljZSIsIl9kZWZhdWx0Q29uZmlnIiwiayIsImdldEl0ZW0iLCJzdG9yZSIsInJlcSIsImdldCIsIml0ZXJhdGUiLCJvcGVuQ3Vyc29yIiwiaXRlcmF0aW9uTnVtYmVyIiwiY3Vyc29yIiwic2V0SXRlbSIsImJsb2JTdXBwb3J0IiwicmVtb3ZlSXRlbSIsImNsZWFyIiwiY291bnQiLCJhZHZhbmNlZCIsIm9wZW5LZXlDdXJzb3IiLCJhZHZhbmNlIiwia2V5cyIsImRyb3BJbnN0YW5jZSIsImN1cnJlbnRDb25maWciLCJjb25maWciLCJpc0N1cnJlbnREYiIsImRiUHJvbWlzZSIsImRyb3BEQlByb21pc2UiLCJkZWxldGVEYXRhYmFzZSIsIm9uYmxvY2tlZCIsIl9mb3JhZ2UiLCJkcm9wT2JqZWN0UHJvbWlzZSIsImRlbGV0ZU9iamVjdFN0b3JlIiwiX2ZvcmFnZTIiLCJhc3luY1N0b3JhZ2UiLCJfZHJpdmVyIiwiX3N1cHBvcnQiLCJpc1dlYlNRTFZhbGlkIiwiQkFTRV9DSEFSUyIsIkJMT0JfVFlQRV9QUkVGSVgiLCJCTE9CX1RZUEVfUFJFRklYX1JFR0VYIiwiU0VSSUFMSVpFRF9NQVJLRVIiLCJTRVJJQUxJWkVEX01BUktFUl9MRU5HVEgiLCJUWVBFX0FSUkFZQlVGRkVSIiwiVFlQRV9CTE9CIiwiVFlQRV9JTlQ4QVJSQVkiLCJUWVBFX1VJTlQ4QVJSQVkiLCJUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZIiwiVFlQRV9JTlQxNkFSUkFZIiwiVFlQRV9JTlQzMkFSUkFZIiwiVFlQRV9VSU5UMTZBUlJBWSIsIlRZUEVfVUlOVDMyQVJSQVkiLCJUWVBFX0ZMT0FUMzJBUlJBWSIsIlRZUEVfRkxPQVQ2NEFSUkFZIiwiVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEgiLCJ0b1N0cmluZyQxIiwic3RyaW5nVG9CdWZmZXIiLCJzZXJpYWxpemVkU3RyaW5nIiwiYnVmZmVyTGVuZ3RoIiwicCIsImVuY29kZWQxIiwiZW5jb2RlZDIiLCJlbmNvZGVkMyIsImVuY29kZWQ0IiwiYnVmZmVyIiwiYnl0ZXMiLCJidWZmZXJUb1N0cmluZyIsImJhc2U2NFN0cmluZyIsInN1YnN0cmluZyIsInNlcmlhbGl6ZSIsInZhbHVlVHlwZSIsIm1hcmtlciIsImZpbGVSZWFkZXIiLCJvbmxvYWQiLCJzdHIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZXNlcmlhbGl6ZSIsInBhcnNlIiwiYmxvYlR5cGUiLCJtYXRjaGVyIiwiSW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJsb2NhbGZvcmFnZVNlcmlhbGl6ZXIiLCJjcmVhdGVEYlRhYmxlIiwiZXhlY3V0ZVNxbCIsIl9pbml0U3RvcmFnZSQxIiwiZGJJbmZvUHJvbWlzZSIsImRlc2NyaXB0aW9uIiwic2l6ZSIsInNlcmlhbGl6ZXIiLCJ0cnlFeGVjdXRlU3FsIiwic3FsU3RhdGVtZW50IiwiYXJncyIsIlNZTlRBWF9FUlIiLCJyZXN1bHRzIiwicm93cyIsImdldEl0ZW0kMSIsIml0ZW0iLCJpdGVyYXRlJDEiLCJfc2V0SXRlbSIsInJldHJpZXNMZWZ0Iiwib3JpZ2luYWxWYWx1ZSIsInNxbEVycm9yIiwiUVVPVEFfRVJSIiwic2V0SXRlbSQxIiwicmVtb3ZlSXRlbSQxIiwiY2xlYXIkMSIsImxlbmd0aCQxIiwiYyIsImtleSQxIiwia2V5cyQxIiwiZ2V0QWxsU3RvcmVOYW1lcyIsInN0b3JlTmFtZXMiLCJkcm9wSW5zdGFuY2UkMSIsIm9wZXJhdGlvbkluZm8iLCJkcm9wVGFibGUiLCJvcGVyYXRpb25zIiwid2ViU1FMU3RvcmFnZSIsImlzTG9jYWxTdG9yYWdlVmFsaWQiLCJsb2NhbFN0b3JhZ2UiLCJfZ2V0S2V5UHJlZml4IiwiZGVmYXVsdENvbmZpZyIsImtleVByZWZpeCIsImNoZWNrSWZMb2NhbFN0b3JhZ2VUaHJvd3MiLCJsb2NhbFN0b3JhZ2VUZXN0S2V5IiwiX2lzTG9jYWxTdG9yYWdlVXNhYmxlIiwiX2luaXRTdG9yYWdlJDIiLCJjbGVhciQyIiwiZ2V0SXRlbSQyIiwiaXRlcmF0ZSQyIiwia2V5UHJlZml4TGVuZ3RoIiwia2V5JDIiLCJrZXlzJDIiLCJpdGVtS2V5IiwibGVuZ3RoJDIiLCJyZW1vdmVJdGVtJDIiLCJzZXRJdGVtJDIiLCJkcm9wSW5zdGFuY2UkMiIsImxvY2FsU3RvcmFnZVdyYXBwZXIiLCJzYW1lVmFsdWUiLCJ4IiwieSIsImlzTmFOIiwiaW5jbHVkZXMiLCJhcnJheSIsInNlYXJjaEVsZW1lbnQiLCJpc0FycmF5IiwiYXJnIiwiRGVmaW5lZERyaXZlcnMiLCJEcml2ZXJTdXBwb3J0IiwiRGVmYXVsdERyaXZlcnMiLCJJTkRFWEVEREIiLCJXRUJTUUwiLCJMT0NBTFNUT1JBR0UiLCJEZWZhdWx0RHJpdmVyT3JkZXIiLCJPcHRpb25hbERyaXZlck1ldGhvZHMiLCJMaWJyYXJ5TWV0aG9kcyIsImNvbmNhdCIsIkRlZmF1bHRDb25maWciLCJkcml2ZXIiLCJjYWxsV2hlblJlYWR5IiwibG9jYWxGb3JhZ2VJbnN0YW5jZSIsImxpYnJhcnlNZXRob2QiLCJfYXJncyIsImV4dGVuZCIsIl9rZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIkxvY2FsRm9yYWdlIiwiZHJpdmVyVHlwZUtleSIsImRyaXZlck5hbWUiLCJkZWZpbmVEcml2ZXIiLCJfY29uZmlnIiwiX2RyaXZlclNldCIsIl9pbml0RHJpdmVyIiwiX3JlYWR5IiwiX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSIsInNldERyaXZlciIsInJlcGxhY2UiLCJkcml2ZXJPYmplY3QiLCJjb21wbGlhbmNlRXJyb3IiLCJkcml2ZXJNZXRob2RzIiwiZHJpdmVyTWV0aG9kTmFtZSIsImlzUmVxdWlyZWQiLCJjb25maWd1cmVNaXNzaW5nTWV0aG9kcyIsIm1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeSIsIm1ldGhvZE5hbWUiLCJfaSIsIl9sZW4iLCJvcHRpb25hbERyaXZlck1ldGhvZCIsInNldERyaXZlclN1cHBvcnQiLCJzdXBwb3J0IiwiaW5mbyIsImdldERyaXZlciIsImdldERyaXZlclByb21pc2UiLCJnZXRTZXJpYWxpemVyIiwic2VyaWFsaXplclByb21pc2UiLCJkcml2ZXJzIiwic3VwcG9ydGVkRHJpdmVycyIsIl9nZXRTdXBwb3J0ZWREcml2ZXJzIiwic2V0RHJpdmVyVG9Db25maWciLCJleHRlbmRTZWxmV2l0aERyaXZlciIsIl9leHRlbmQiLCJpbml0RHJpdmVyIiwiY3VycmVudERyaXZlckluZGV4IiwiZHJpdmVyUHJvbWlzZUxvb3AiLCJvbGREcml2ZXJTZXREb25lIiwic3VwcG9ydHMiLCJsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMiLCJjcmVhdGVJbnN0YW5jZSIsImxvY2FsZm9yYWdlX2pzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/localforage/dist/localforage.js\n");

/***/ })

};
;